// Code generated by counterfeiter. DO NOT EDIT.
package docker

import (
	"io"
	"net"
	"sync"
	"time"

	"github.com/docker/docker/api/types"
	containertypes "github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/events"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/api/types/image"
	networktypes "github.com/docker/docker/api/types/network"
	"github.com/docker/docker/api/types/registry"
	swarmPkg "github.com/docker/docker/api/types/swarm"
	volumetypes "github.com/docker/docker/api/types/volume"
	"github.com/docker/docker/client"
	contextPkg "golang.org/x/net/context"
)

type fakeDockerClient struct {
	ConfigListStub        func(ctx contextPkg.Context, options types.ConfigListOptions) ([]swarmPkg.Config, error)
	configListMutex       sync.RWMutex
	configListArgsForCall []struct {
		ctx     contextPkg.Context
		options types.ConfigListOptions
	}
	configListReturns struct {
		result1 []swarmPkg.Config
		result2 error
	}
	configListReturnsOnCall map[int]struct {
		result1 []swarmPkg.Config
		result2 error
	}
	ConfigCreateStub        func(ctx contextPkg.Context, config swarmPkg.ConfigSpec) (types.ConfigCreateResponse, error)
	configCreateMutex       sync.RWMutex
	configCreateArgsForCall []struct {
		ctx    contextPkg.Context
		config swarmPkg.ConfigSpec
	}
	configCreateReturns struct {
		result1 types.ConfigCreateResponse
		result2 error
	}
	configCreateReturnsOnCall map[int]struct {
		result1 types.ConfigCreateResponse
		result2 error
	}
	ConfigRemoveStub        func(ctx contextPkg.Context, id string) error
	configRemoveMutex       sync.RWMutex
	configRemoveArgsForCall []struct {
		ctx contextPkg.Context
		id  string
	}
	configRemoveReturns struct {
		result1 error
	}
	configRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigInspectWithRawStub        func(ctx contextPkg.Context, name string) (swarmPkg.Config, []byte, error)
	configInspectWithRawMutex       sync.RWMutex
	configInspectWithRawArgsForCall []struct {
		ctx  contextPkg.Context
		name string
	}
	configInspectWithRawReturns struct {
		result1 swarmPkg.Config
		result2 []byte
		result3 error
	}
	configInspectWithRawReturnsOnCall map[int]struct {
		result1 swarmPkg.Config
		result2 []byte
		result3 error
	}
	ConfigUpdateStub        func(ctx contextPkg.Context, id string, version swarmPkg.Version, config swarmPkg.ConfigSpec) error
	configUpdateMutex       sync.RWMutex
	configUpdateArgsForCall []struct {
		ctx     contextPkg.Context
		id      string
		version swarmPkg.Version
		config  swarmPkg.ConfigSpec
	}
	configUpdateReturns struct {
		result1 error
	}
	configUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerAttachStub        func(ctx contextPkg.Context, container string, options types.ContainerAttachOptions) (types.HijackedResponse, error)
	containerAttachMutex       sync.RWMutex
	containerAttachArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		options   types.ContainerAttachOptions
	}
	containerAttachReturns struct {
		result1 types.HijackedResponse
		result2 error
	}
	containerAttachReturnsOnCall map[int]struct {
		result1 types.HijackedResponse
		result2 error
	}
	ContainerCommitStub        func(ctx contextPkg.Context, container string, options types.ContainerCommitOptions) (types.IDResponse, error)
	containerCommitMutex       sync.RWMutex
	containerCommitArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		options   types.ContainerCommitOptions
	}
	containerCommitReturns struct {
		result1 types.IDResponse
		result2 error
	}
	containerCommitReturnsOnCall map[int]struct {
		result1 types.IDResponse
		result2 error
	}
	ContainerCreateStub        func(ctx contextPkg.Context, config *containertypes.Config, hostConfig *containertypes.HostConfig, networkingConfig *networktypes.NetworkingConfig, containerName string) (containertypes.ContainerCreateCreatedBody, error)
	containerCreateMutex       sync.RWMutex
	containerCreateArgsForCall []struct {
		ctx              contextPkg.Context
		config           *containertypes.Config
		hostConfig       *containertypes.HostConfig
		networkingConfig *networktypes.NetworkingConfig
		containerName    string
	}
	containerCreateReturns struct {
		result1 containertypes.ContainerCreateCreatedBody
		result2 error
	}
	containerCreateReturnsOnCall map[int]struct {
		result1 containertypes.ContainerCreateCreatedBody
		result2 error
	}
	ContainerDiffStub        func(ctx contextPkg.Context, container string) ([]containertypes.ContainerChangeResponseItem, error)
	containerDiffMutex       sync.RWMutex
	containerDiffArgsForCall []struct {
		ctx       contextPkg.Context
		container string
	}
	containerDiffReturns struct {
		result1 []containertypes.ContainerChangeResponseItem
		result2 error
	}
	containerDiffReturnsOnCall map[int]struct {
		result1 []containertypes.ContainerChangeResponseItem
		result2 error
	}
	ContainerExecAttachStub        func(ctx contextPkg.Context, execID string, config types.ExecStartCheck) (types.HijackedResponse, error)
	containerExecAttachMutex       sync.RWMutex
	containerExecAttachArgsForCall []struct {
		ctx    contextPkg.Context
		execID string
		config types.ExecStartCheck
	}
	containerExecAttachReturns struct {
		result1 types.HijackedResponse
		result2 error
	}
	containerExecAttachReturnsOnCall map[int]struct {
		result1 types.HijackedResponse
		result2 error
	}
	ContainerExecCreateStub        func(ctx contextPkg.Context, container string, config types.ExecConfig) (types.IDResponse, error)
	containerExecCreateMutex       sync.RWMutex
	containerExecCreateArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		config    types.ExecConfig
	}
	containerExecCreateReturns struct {
		result1 types.IDResponse
		result2 error
	}
	containerExecCreateReturnsOnCall map[int]struct {
		result1 types.IDResponse
		result2 error
	}
	ContainerExecInspectStub        func(ctx contextPkg.Context, execID string) (types.ContainerExecInspect, error)
	containerExecInspectMutex       sync.RWMutex
	containerExecInspectArgsForCall []struct {
		ctx    contextPkg.Context
		execID string
	}
	containerExecInspectReturns struct {
		result1 types.ContainerExecInspect
		result2 error
	}
	containerExecInspectReturnsOnCall map[int]struct {
		result1 types.ContainerExecInspect
		result2 error
	}
	ContainerExecResizeStub        func(ctx contextPkg.Context, execID string, options types.ResizeOptions) error
	containerExecResizeMutex       sync.RWMutex
	containerExecResizeArgsForCall []struct {
		ctx     contextPkg.Context
		execID  string
		options types.ResizeOptions
	}
	containerExecResizeReturns struct {
		result1 error
	}
	containerExecResizeReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerExecStartStub        func(ctx contextPkg.Context, execID string, config types.ExecStartCheck) error
	containerExecStartMutex       sync.RWMutex
	containerExecStartArgsForCall []struct {
		ctx    contextPkg.Context
		execID string
		config types.ExecStartCheck
	}
	containerExecStartReturns struct {
		result1 error
	}
	containerExecStartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerExportStub        func(ctx contextPkg.Context, container string) (io.ReadCloser, error)
	containerExportMutex       sync.RWMutex
	containerExportArgsForCall []struct {
		ctx       contextPkg.Context
		container string
	}
	containerExportReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	containerExportReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerInspectStub        func(ctx contextPkg.Context, container string) (types.ContainerJSON, error)
	containerInspectMutex       sync.RWMutex
	containerInspectArgsForCall []struct {
		ctx       contextPkg.Context
		container string
	}
	containerInspectReturns struct {
		result1 types.ContainerJSON
		result2 error
	}
	containerInspectReturnsOnCall map[int]struct {
		result1 types.ContainerJSON
		result2 error
	}
	ContainerInspectWithRawStub        func(ctx contextPkg.Context, container string, getSize bool) (types.ContainerJSON, []byte, error)
	containerInspectWithRawMutex       sync.RWMutex
	containerInspectWithRawArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		getSize   bool
	}
	containerInspectWithRawReturns struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}
	containerInspectWithRawReturnsOnCall map[int]struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}
	ContainerKillStub        func(ctx contextPkg.Context, container, signal string) error
	containerKillMutex       sync.RWMutex
	containerKillArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		signal    string
	}
	containerKillReturns struct {
		result1 error
	}
	containerKillReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerListStub        func(ctx contextPkg.Context, options types.ContainerListOptions) ([]types.Container, error)
	containerListMutex       sync.RWMutex
	containerListArgsForCall []struct {
		ctx     contextPkg.Context
		options types.ContainerListOptions
	}
	containerListReturns struct {
		result1 []types.Container
		result2 error
	}
	containerListReturnsOnCall map[int]struct {
		result1 []types.Container
		result2 error
	}
	ContainerLogsStub        func(ctx contextPkg.Context, container string, options types.ContainerLogsOptions) (io.ReadCloser, error)
	containerLogsMutex       sync.RWMutex
	containerLogsArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		options   types.ContainerLogsOptions
	}
	containerLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	containerLogsReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerPauseStub        func(ctx contextPkg.Context, container string) error
	containerPauseMutex       sync.RWMutex
	containerPauseArgsForCall []struct {
		ctx       contextPkg.Context
		container string
	}
	containerPauseReturns struct {
		result1 error
	}
	containerPauseReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerRemoveStub        func(ctx contextPkg.Context, container string, options types.ContainerRemoveOptions) error
	containerRemoveMutex       sync.RWMutex
	containerRemoveArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		options   types.ContainerRemoveOptions
	}
	containerRemoveReturns struct {
		result1 error
	}
	containerRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerRenameStub        func(ctx contextPkg.Context, container, newContainerName string) error
	containerRenameMutex       sync.RWMutex
	containerRenameArgsForCall []struct {
		ctx              contextPkg.Context
		container        string
		newContainerName string
	}
	containerRenameReturns struct {
		result1 error
	}
	containerRenameReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerResizeStub        func(ctx contextPkg.Context, container string, options types.ResizeOptions) error
	containerResizeMutex       sync.RWMutex
	containerResizeArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		options   types.ResizeOptions
	}
	containerResizeReturns struct {
		result1 error
	}
	containerResizeReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerRestartStub        func(ctx contextPkg.Context, container string, timeout *time.Duration) error
	containerRestartMutex       sync.RWMutex
	containerRestartArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		timeout   *time.Duration
	}
	containerRestartReturns struct {
		result1 error
	}
	containerRestartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStatPathStub        func(ctx contextPkg.Context, container, path string) (types.ContainerPathStat, error)
	containerStatPathMutex       sync.RWMutex
	containerStatPathArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		path      string
	}
	containerStatPathReturns struct {
		result1 types.ContainerPathStat
		result2 error
	}
	containerStatPathReturnsOnCall map[int]struct {
		result1 types.ContainerPathStat
		result2 error
	}
	ContainerStatsStub        func(ctx contextPkg.Context, container string, stream bool) (types.ContainerStats, error)
	containerStatsMutex       sync.RWMutex
	containerStatsArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		stream    bool
	}
	containerStatsReturns struct {
		result1 types.ContainerStats
		result2 error
	}
	containerStatsReturnsOnCall map[int]struct {
		result1 types.ContainerStats
		result2 error
	}
	ContainerStartStub        func(ctx contextPkg.Context, container string, options types.ContainerStartOptions) error
	containerStartMutex       sync.RWMutex
	containerStartArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		options   types.ContainerStartOptions
	}
	containerStartReturns struct {
		result1 error
	}
	containerStartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStopStub        func(ctx contextPkg.Context, container string, timeout *time.Duration) error
	containerStopMutex       sync.RWMutex
	containerStopArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		timeout   *time.Duration
	}
	containerStopReturns struct {
		result1 error
	}
	containerStopReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerTopStub        func(ctx contextPkg.Context, container string, arguments []string) (containertypes.ContainerTopOKBody, error)
	containerTopMutex       sync.RWMutex
	containerTopArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		arguments []string
	}
	containerTopReturns struct {
		result1 containertypes.ContainerTopOKBody
		result2 error
	}
	containerTopReturnsOnCall map[int]struct {
		result1 containertypes.ContainerTopOKBody
		result2 error
	}
	ContainerUnpauseStub        func(ctx contextPkg.Context, container string) error
	containerUnpauseMutex       sync.RWMutex
	containerUnpauseArgsForCall []struct {
		ctx       contextPkg.Context
		container string
	}
	containerUnpauseReturns struct {
		result1 error
	}
	containerUnpauseReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerUpdateStub        func(ctx contextPkg.Context, container string, updateConfig containertypes.UpdateConfig) (containertypes.ContainerUpdateOKBody, error)
	containerUpdateMutex       sync.RWMutex
	containerUpdateArgsForCall []struct {
		ctx          contextPkg.Context
		container    string
		updateConfig containertypes.UpdateConfig
	}
	containerUpdateReturns struct {
		result1 containertypes.ContainerUpdateOKBody
		result2 error
	}
	containerUpdateReturnsOnCall map[int]struct {
		result1 containertypes.ContainerUpdateOKBody
		result2 error
	}
	ContainerWaitStub        func(ctx contextPkg.Context, container string, condition containertypes.WaitCondition) (<-chan containertypes.ContainerWaitOKBody, <-chan error)
	containerWaitMutex       sync.RWMutex
	containerWaitArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		condition containertypes.WaitCondition
	}
	containerWaitReturns struct {
		result1 <-chan containertypes.ContainerWaitOKBody
		result2 <-chan error
	}
	containerWaitReturnsOnCall map[int]struct {
		result1 <-chan containertypes.ContainerWaitOKBody
		result2 <-chan error
	}
	CopyFromContainerStub        func(ctx contextPkg.Context, container, srcPath string) (io.ReadCloser, types.ContainerPathStat, error)
	copyFromContainerMutex       sync.RWMutex
	copyFromContainerArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		srcPath   string
	}
	copyFromContainerReturns struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}
	copyFromContainerReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}
	CopyToContainerStub        func(ctx contextPkg.Context, container, path string, content io.Reader, options types.CopyToContainerOptions) error
	copyToContainerMutex       sync.RWMutex
	copyToContainerArgsForCall []struct {
		ctx       contextPkg.Context
		container string
		path      string
		content   io.Reader
		options   types.CopyToContainerOptions
	}
	copyToContainerReturns struct {
		result1 error
	}
	copyToContainerReturnsOnCall map[int]struct {
		result1 error
	}
	ContainersPruneStub        func(ctx contextPkg.Context, pruneFilters filters.Args) (types.ContainersPruneReport, error)
	containersPruneMutex       sync.RWMutex
	containersPruneArgsForCall []struct {
		ctx          contextPkg.Context
		pruneFilters filters.Args
	}
	containersPruneReturns struct {
		result1 types.ContainersPruneReport
		result2 error
	}
	containersPruneReturnsOnCall map[int]struct {
		result1 types.ContainersPruneReport
		result2 error
	}
	DistributionInspectStub        func(ctx contextPkg.Context, image, encodedRegistryAuth string) (registry.DistributionInspect, error)
	distributionInspectMutex       sync.RWMutex
	distributionInspectArgsForCall []struct {
		ctx                 contextPkg.Context
		image               string
		encodedRegistryAuth string
	}
	distributionInspectReturns struct {
		result1 registry.DistributionInspect
		result2 error
	}
	distributionInspectReturnsOnCall map[int]struct {
		result1 registry.DistributionInspect
		result2 error
	}
	ImageBuildStub        func(ctx contextPkg.Context, context io.Reader, options types.ImageBuildOptions) (types.ImageBuildResponse, error)
	imageBuildMutex       sync.RWMutex
	imageBuildArgsForCall []struct {
		ctx     contextPkg.Context
		context io.Reader
		options types.ImageBuildOptions
	}
	imageBuildReturns struct {
		result1 types.ImageBuildResponse
		result2 error
	}
	imageBuildReturnsOnCall map[int]struct {
		result1 types.ImageBuildResponse
		result2 error
	}
	BuildCachePruneStub        func(ctx contextPkg.Context) (*types.BuildCachePruneReport, error)
	buildCachePruneMutex       sync.RWMutex
	buildCachePruneArgsForCall []struct {
		ctx contextPkg.Context
	}
	buildCachePruneReturns struct {
		result1 *types.BuildCachePruneReport
		result2 error
	}
	buildCachePruneReturnsOnCall map[int]struct {
		result1 *types.BuildCachePruneReport
		result2 error
	}
	ImageCreateStub        func(ctx contextPkg.Context, parentReference string, options types.ImageCreateOptions) (io.ReadCloser, error)
	imageCreateMutex       sync.RWMutex
	imageCreateArgsForCall []struct {
		ctx             contextPkg.Context
		parentReference string
		options         types.ImageCreateOptions
	}
	imageCreateReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imageCreateReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageHistoryStub        func(ctx contextPkg.Context, image string) ([]image.HistoryResponseItem, error)
	imageHistoryMutex       sync.RWMutex
	imageHistoryArgsForCall []struct {
		ctx   contextPkg.Context
		image string
	}
	imageHistoryReturns struct {
		result1 []image.HistoryResponseItem
		result2 error
	}
	imageHistoryReturnsOnCall map[int]struct {
		result1 []image.HistoryResponseItem
		result2 error
	}
	ImageImportStub        func(ctx contextPkg.Context, source types.ImageImportSource, ref string, options types.ImageImportOptions) (io.ReadCloser, error)
	imageImportMutex       sync.RWMutex
	imageImportArgsForCall []struct {
		ctx     contextPkg.Context
		source  types.ImageImportSource
		ref     string
		options types.ImageImportOptions
	}
	imageImportReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imageImportReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageInspectWithRawStub        func(ctx contextPkg.Context, image string) (types.ImageInspect, []byte, error)
	imageInspectWithRawMutex       sync.RWMutex
	imageInspectWithRawArgsForCall []struct {
		ctx   contextPkg.Context
		image string
	}
	imageInspectWithRawReturns struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}
	imageInspectWithRawReturnsOnCall map[int]struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}
	ImageListStub        func(ctx contextPkg.Context, options types.ImageListOptions) ([]types.ImageSummary, error)
	imageListMutex       sync.RWMutex
	imageListArgsForCall []struct {
		ctx     contextPkg.Context
		options types.ImageListOptions
	}
	imageListReturns struct {
		result1 []types.ImageSummary
		result2 error
	}
	imageListReturnsOnCall map[int]struct {
		result1 []types.ImageSummary
		result2 error
	}
	ImageLoadStub        func(ctx contextPkg.Context, input io.Reader, quiet bool) (types.ImageLoadResponse, error)
	imageLoadMutex       sync.RWMutex
	imageLoadArgsForCall []struct {
		ctx   contextPkg.Context
		input io.Reader
		quiet bool
	}
	imageLoadReturns struct {
		result1 types.ImageLoadResponse
		result2 error
	}
	imageLoadReturnsOnCall map[int]struct {
		result1 types.ImageLoadResponse
		result2 error
	}
	ImagePullStub        func(ctx contextPkg.Context, ref string, options types.ImagePullOptions) (io.ReadCloser, error)
	imagePullMutex       sync.RWMutex
	imagePullArgsForCall []struct {
		ctx     contextPkg.Context
		ref     string
		options types.ImagePullOptions
	}
	imagePullReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imagePullReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImagePushStub        func(ctx contextPkg.Context, ref string, options types.ImagePushOptions) (io.ReadCloser, error)
	imagePushMutex       sync.RWMutex
	imagePushArgsForCall []struct {
		ctx     contextPkg.Context
		ref     string
		options types.ImagePushOptions
	}
	imagePushReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imagePushReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageRemoveStub        func(ctx contextPkg.Context, image string, options types.ImageRemoveOptions) ([]types.ImageDeleteResponseItem, error)
	imageRemoveMutex       sync.RWMutex
	imageRemoveArgsForCall []struct {
		ctx     contextPkg.Context
		image   string
		options types.ImageRemoveOptions
	}
	imageRemoveReturns struct {
		result1 []types.ImageDeleteResponseItem
		result2 error
	}
	imageRemoveReturnsOnCall map[int]struct {
		result1 []types.ImageDeleteResponseItem
		result2 error
	}
	ImageSearchStub        func(ctx contextPkg.Context, term string, options types.ImageSearchOptions) ([]registry.SearchResult, error)
	imageSearchMutex       sync.RWMutex
	imageSearchArgsForCall []struct {
		ctx     contextPkg.Context
		term    string
		options types.ImageSearchOptions
	}
	imageSearchReturns struct {
		result1 []registry.SearchResult
		result2 error
	}
	imageSearchReturnsOnCall map[int]struct {
		result1 []registry.SearchResult
		result2 error
	}
	ImageSaveStub        func(ctx contextPkg.Context, images []string) (io.ReadCloser, error)
	imageSaveMutex       sync.RWMutex
	imageSaveArgsForCall []struct {
		ctx    contextPkg.Context
		images []string
	}
	imageSaveReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imageSaveReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageTagStub        func(ctx contextPkg.Context, image, ref string) error
	imageTagMutex       sync.RWMutex
	imageTagArgsForCall []struct {
		ctx   contextPkg.Context
		image string
		ref   string
	}
	imageTagReturns struct {
		result1 error
	}
	imageTagReturnsOnCall map[int]struct {
		result1 error
	}
	ImagesPruneStub        func(ctx contextPkg.Context, pruneFilter filters.Args) (types.ImagesPruneReport, error)
	imagesPruneMutex       sync.RWMutex
	imagesPruneArgsForCall []struct {
		ctx         contextPkg.Context
		pruneFilter filters.Args
	}
	imagesPruneReturns struct {
		result1 types.ImagesPruneReport
		result2 error
	}
	imagesPruneReturnsOnCall map[int]struct {
		result1 types.ImagesPruneReport
		result2 error
	}
	NodeInspectWithRawStub        func(ctx contextPkg.Context, nodeID string) (swarmPkg.Node, []byte, error)
	nodeInspectWithRawMutex       sync.RWMutex
	nodeInspectWithRawArgsForCall []struct {
		ctx    contextPkg.Context
		nodeID string
	}
	nodeInspectWithRawReturns struct {
		result1 swarmPkg.Node
		result2 []byte
		result3 error
	}
	nodeInspectWithRawReturnsOnCall map[int]struct {
		result1 swarmPkg.Node
		result2 []byte
		result3 error
	}
	NodeListStub        func(ctx contextPkg.Context, options types.NodeListOptions) ([]swarmPkg.Node, error)
	nodeListMutex       sync.RWMutex
	nodeListArgsForCall []struct {
		ctx     contextPkg.Context
		options types.NodeListOptions
	}
	nodeListReturns struct {
		result1 []swarmPkg.Node
		result2 error
	}
	nodeListReturnsOnCall map[int]struct {
		result1 []swarmPkg.Node
		result2 error
	}
	NodeRemoveStub        func(ctx contextPkg.Context, nodeID string, options types.NodeRemoveOptions) error
	nodeRemoveMutex       sync.RWMutex
	nodeRemoveArgsForCall []struct {
		ctx     contextPkg.Context
		nodeID  string
		options types.NodeRemoveOptions
	}
	nodeRemoveReturns struct {
		result1 error
	}
	nodeRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	NodeUpdateStub        func(ctx contextPkg.Context, nodeID string, version swarmPkg.Version, node swarmPkg.NodeSpec) error
	nodeUpdateMutex       sync.RWMutex
	nodeUpdateArgsForCall []struct {
		ctx     contextPkg.Context
		nodeID  string
		version swarmPkg.Version
		node    swarmPkg.NodeSpec
	}
	nodeUpdateReturns struct {
		result1 error
	}
	nodeUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	NetworkConnectStub        func(ctx contextPkg.Context, network, container string, config *networktypes.EndpointSettings) error
	networkConnectMutex       sync.RWMutex
	networkConnectArgsForCall []struct {
		ctx       contextPkg.Context
		network   string
		container string
		config    *networktypes.EndpointSettings
	}
	networkConnectReturns struct {
		result1 error
	}
	networkConnectReturnsOnCall map[int]struct {
		result1 error
	}
	NetworkCreateStub        func(ctx contextPkg.Context, name string, options types.NetworkCreate) (types.NetworkCreateResponse, error)
	networkCreateMutex       sync.RWMutex
	networkCreateArgsForCall []struct {
		ctx     contextPkg.Context
		name    string
		options types.NetworkCreate
	}
	networkCreateReturns struct {
		result1 types.NetworkCreateResponse
		result2 error
	}
	networkCreateReturnsOnCall map[int]struct {
		result1 types.NetworkCreateResponse
		result2 error
	}
	NetworkDisconnectStub        func(ctx contextPkg.Context, network, container string, force bool) error
	networkDisconnectMutex       sync.RWMutex
	networkDisconnectArgsForCall []struct {
		ctx       contextPkg.Context
		network   string
		container string
		force     bool
	}
	networkDisconnectReturns struct {
		result1 error
	}
	networkDisconnectReturnsOnCall map[int]struct {
		result1 error
	}
	NetworkInspectStub        func(ctx contextPkg.Context, network string, options types.NetworkInspectOptions) (types.NetworkResource, error)
	networkInspectMutex       sync.RWMutex
	networkInspectArgsForCall []struct {
		ctx     contextPkg.Context
		network string
		options types.NetworkInspectOptions
	}
	networkInspectReturns struct {
		result1 types.NetworkResource
		result2 error
	}
	networkInspectReturnsOnCall map[int]struct {
		result1 types.NetworkResource
		result2 error
	}
	NetworkInspectWithRawStub        func(ctx contextPkg.Context, network string, options types.NetworkInspectOptions) (types.NetworkResource, []byte, error)
	networkInspectWithRawMutex       sync.RWMutex
	networkInspectWithRawArgsForCall []struct {
		ctx     contextPkg.Context
		network string
		options types.NetworkInspectOptions
	}
	networkInspectWithRawReturns struct {
		result1 types.NetworkResource
		result2 []byte
		result3 error
	}
	networkInspectWithRawReturnsOnCall map[int]struct {
		result1 types.NetworkResource
		result2 []byte
		result3 error
	}
	NetworkListStub        func(ctx contextPkg.Context, options types.NetworkListOptions) ([]types.NetworkResource, error)
	networkListMutex       sync.RWMutex
	networkListArgsForCall []struct {
		ctx     contextPkg.Context
		options types.NetworkListOptions
	}
	networkListReturns struct {
		result1 []types.NetworkResource
		result2 error
	}
	networkListReturnsOnCall map[int]struct {
		result1 []types.NetworkResource
		result2 error
	}
	NetworkRemoveStub        func(ctx contextPkg.Context, network string) error
	networkRemoveMutex       sync.RWMutex
	networkRemoveArgsForCall []struct {
		ctx     contextPkg.Context
		network string
	}
	networkRemoveReturns struct {
		result1 error
	}
	networkRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	NetworksPruneStub        func(ctx contextPkg.Context, pruneFilter filters.Args) (types.NetworksPruneReport, error)
	networksPruneMutex       sync.RWMutex
	networksPruneArgsForCall []struct {
		ctx         contextPkg.Context
		pruneFilter filters.Args
	}
	networksPruneReturns struct {
		result1 types.NetworksPruneReport
		result2 error
	}
	networksPruneReturnsOnCall map[int]struct {
		result1 types.NetworksPruneReport
		result2 error
	}
	PluginListStub        func(ctx contextPkg.Context, filter filters.Args) (types.PluginsListResponse, error)
	pluginListMutex       sync.RWMutex
	pluginListArgsForCall []struct {
		ctx    contextPkg.Context
		filter filters.Args
	}
	pluginListReturns struct {
		result1 types.PluginsListResponse
		result2 error
	}
	pluginListReturnsOnCall map[int]struct {
		result1 types.PluginsListResponse
		result2 error
	}
	PluginRemoveStub        func(ctx contextPkg.Context, name string, options types.PluginRemoveOptions) error
	pluginRemoveMutex       sync.RWMutex
	pluginRemoveArgsForCall []struct {
		ctx     contextPkg.Context
		name    string
		options types.PluginRemoveOptions
	}
	pluginRemoveReturns struct {
		result1 error
	}
	pluginRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	PluginEnableStub        func(ctx contextPkg.Context, name string, options types.PluginEnableOptions) error
	pluginEnableMutex       sync.RWMutex
	pluginEnableArgsForCall []struct {
		ctx     contextPkg.Context
		name    string
		options types.PluginEnableOptions
	}
	pluginEnableReturns struct {
		result1 error
	}
	pluginEnableReturnsOnCall map[int]struct {
		result1 error
	}
	PluginDisableStub        func(ctx contextPkg.Context, name string, options types.PluginDisableOptions) error
	pluginDisableMutex       sync.RWMutex
	pluginDisableArgsForCall []struct {
		ctx     contextPkg.Context
		name    string
		options types.PluginDisableOptions
	}
	pluginDisableReturns struct {
		result1 error
	}
	pluginDisableReturnsOnCall map[int]struct {
		result1 error
	}
	PluginInstallStub        func(ctx contextPkg.Context, name string, options types.PluginInstallOptions) (io.ReadCloser, error)
	pluginInstallMutex       sync.RWMutex
	pluginInstallArgsForCall []struct {
		ctx     contextPkg.Context
		name    string
		options types.PluginInstallOptions
	}
	pluginInstallReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	pluginInstallReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	PluginUpgradeStub        func(ctx contextPkg.Context, name string, options types.PluginInstallOptions) (io.ReadCloser, error)
	pluginUpgradeMutex       sync.RWMutex
	pluginUpgradeArgsForCall []struct {
		ctx     contextPkg.Context
		name    string
		options types.PluginInstallOptions
	}
	pluginUpgradeReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	pluginUpgradeReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	PluginPushStub        func(ctx contextPkg.Context, name string, registryAuth string) (io.ReadCloser, error)
	pluginPushMutex       sync.RWMutex
	pluginPushArgsForCall []struct {
		ctx          contextPkg.Context
		name         string
		registryAuth string
	}
	pluginPushReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	pluginPushReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	PluginSetStub        func(ctx contextPkg.Context, name string, args []string) error
	pluginSetMutex       sync.RWMutex
	pluginSetArgsForCall []struct {
		ctx  contextPkg.Context
		name string
		args []string
	}
	pluginSetReturns struct {
		result1 error
	}
	pluginSetReturnsOnCall map[int]struct {
		result1 error
	}
	PluginInspectWithRawStub        func(ctx contextPkg.Context, name string) (*types.Plugin, []byte, error)
	pluginInspectWithRawMutex       sync.RWMutex
	pluginInspectWithRawArgsForCall []struct {
		ctx  contextPkg.Context
		name string
	}
	pluginInspectWithRawReturns struct {
		result1 *types.Plugin
		result2 []byte
		result3 error
	}
	pluginInspectWithRawReturnsOnCall map[int]struct {
		result1 *types.Plugin
		result2 []byte
		result3 error
	}
	PluginCreateStub        func(ctx contextPkg.Context, createContext io.Reader, options types.PluginCreateOptions) error
	pluginCreateMutex       sync.RWMutex
	pluginCreateArgsForCall []struct {
		ctx           contextPkg.Context
		createContext io.Reader
		options       types.PluginCreateOptions
	}
	pluginCreateReturns struct {
		result1 error
	}
	pluginCreateReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceCreateStub        func(ctx contextPkg.Context, service swarmPkg.ServiceSpec, options types.ServiceCreateOptions) (types.ServiceCreateResponse, error)
	serviceCreateMutex       sync.RWMutex
	serviceCreateArgsForCall []struct {
		ctx     contextPkg.Context
		service swarmPkg.ServiceSpec
		options types.ServiceCreateOptions
	}
	serviceCreateReturns struct {
		result1 types.ServiceCreateResponse
		result2 error
	}
	serviceCreateReturnsOnCall map[int]struct {
		result1 types.ServiceCreateResponse
		result2 error
	}
	ServiceInspectWithRawStub        func(ctx contextPkg.Context, serviceID string, options types.ServiceInspectOptions) (swarmPkg.Service, []byte, error)
	serviceInspectWithRawMutex       sync.RWMutex
	serviceInspectWithRawArgsForCall []struct {
		ctx       contextPkg.Context
		serviceID string
		options   types.ServiceInspectOptions
	}
	serviceInspectWithRawReturns struct {
		result1 swarmPkg.Service
		result2 []byte
		result3 error
	}
	serviceInspectWithRawReturnsOnCall map[int]struct {
		result1 swarmPkg.Service
		result2 []byte
		result3 error
	}
	ServiceListStub        func(ctx contextPkg.Context, options types.ServiceListOptions) ([]swarmPkg.Service, error)
	serviceListMutex       sync.RWMutex
	serviceListArgsForCall []struct {
		ctx     contextPkg.Context
		options types.ServiceListOptions
	}
	serviceListReturns struct {
		result1 []swarmPkg.Service
		result2 error
	}
	serviceListReturnsOnCall map[int]struct {
		result1 []swarmPkg.Service
		result2 error
	}
	ServiceRemoveStub        func(ctx contextPkg.Context, serviceID string) error
	serviceRemoveMutex       sync.RWMutex
	serviceRemoveArgsForCall []struct {
		ctx       contextPkg.Context
		serviceID string
	}
	serviceRemoveReturns struct {
		result1 error
	}
	serviceRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceUpdateStub        func(ctx contextPkg.Context, serviceID string, version swarmPkg.Version, service swarmPkg.ServiceSpec, options types.ServiceUpdateOptions) (types.ServiceUpdateResponse, error)
	serviceUpdateMutex       sync.RWMutex
	serviceUpdateArgsForCall []struct {
		ctx       contextPkg.Context
		serviceID string
		version   swarmPkg.Version
		service   swarmPkg.ServiceSpec
		options   types.ServiceUpdateOptions
	}
	serviceUpdateReturns struct {
		result1 types.ServiceUpdateResponse
		result2 error
	}
	serviceUpdateReturnsOnCall map[int]struct {
		result1 types.ServiceUpdateResponse
		result2 error
	}
	ServiceLogsStub        func(ctx contextPkg.Context, serviceID string, options types.ContainerLogsOptions) (io.ReadCloser, error)
	serviceLogsMutex       sync.RWMutex
	serviceLogsArgsForCall []struct {
		ctx       contextPkg.Context
		serviceID string
		options   types.ContainerLogsOptions
	}
	serviceLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	serviceLogsReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	TaskLogsStub        func(ctx contextPkg.Context, taskID string, options types.ContainerLogsOptions) (io.ReadCloser, error)
	taskLogsMutex       sync.RWMutex
	taskLogsArgsForCall []struct {
		ctx     contextPkg.Context
		taskID  string
		options types.ContainerLogsOptions
	}
	taskLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	taskLogsReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	TaskInspectWithRawStub        func(ctx contextPkg.Context, taskID string) (swarmPkg.Task, []byte, error)
	taskInspectWithRawMutex       sync.RWMutex
	taskInspectWithRawArgsForCall []struct {
		ctx    contextPkg.Context
		taskID string
	}
	taskInspectWithRawReturns struct {
		result1 swarmPkg.Task
		result2 []byte
		result3 error
	}
	taskInspectWithRawReturnsOnCall map[int]struct {
		result1 swarmPkg.Task
		result2 []byte
		result3 error
	}
	TaskListStub        func(ctx contextPkg.Context, options types.TaskListOptions) ([]swarmPkg.Task, error)
	taskListMutex       sync.RWMutex
	taskListArgsForCall []struct {
		ctx     contextPkg.Context
		options types.TaskListOptions
	}
	taskListReturns struct {
		result1 []swarmPkg.Task
		result2 error
	}
	taskListReturnsOnCall map[int]struct {
		result1 []swarmPkg.Task
		result2 error
	}
	SwarmInitStub        func(ctx contextPkg.Context, req swarmPkg.InitRequest) (string, error)
	swarmInitMutex       sync.RWMutex
	swarmInitArgsForCall []struct {
		ctx contextPkg.Context
		req swarmPkg.InitRequest
	}
	swarmInitReturns struct {
		result1 string
		result2 error
	}
	swarmInitReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SwarmJoinStub        func(ctx contextPkg.Context, req swarmPkg.JoinRequest) error
	swarmJoinMutex       sync.RWMutex
	swarmJoinArgsForCall []struct {
		ctx contextPkg.Context
		req swarmPkg.JoinRequest
	}
	swarmJoinReturns struct {
		result1 error
	}
	swarmJoinReturnsOnCall map[int]struct {
		result1 error
	}
	SwarmGetUnlockKeyStub        func(ctx contextPkg.Context) (types.SwarmUnlockKeyResponse, error)
	swarmGetUnlockKeyMutex       sync.RWMutex
	swarmGetUnlockKeyArgsForCall []struct {
		ctx contextPkg.Context
	}
	swarmGetUnlockKeyReturns struct {
		result1 types.SwarmUnlockKeyResponse
		result2 error
	}
	swarmGetUnlockKeyReturnsOnCall map[int]struct {
		result1 types.SwarmUnlockKeyResponse
		result2 error
	}
	SwarmUnlockStub        func(ctx contextPkg.Context, req swarmPkg.UnlockRequest) error
	swarmUnlockMutex       sync.RWMutex
	swarmUnlockArgsForCall []struct {
		ctx contextPkg.Context
		req swarmPkg.UnlockRequest
	}
	swarmUnlockReturns struct {
		result1 error
	}
	swarmUnlockReturnsOnCall map[int]struct {
		result1 error
	}
	SwarmLeaveStub        func(ctx contextPkg.Context, force bool) error
	swarmLeaveMutex       sync.RWMutex
	swarmLeaveArgsForCall []struct {
		ctx   contextPkg.Context
		force bool
	}
	swarmLeaveReturns struct {
		result1 error
	}
	swarmLeaveReturnsOnCall map[int]struct {
		result1 error
	}
	SwarmInspectStub        func(ctx contextPkg.Context) (swarmPkg.Swarm, error)
	swarmInspectMutex       sync.RWMutex
	swarmInspectArgsForCall []struct {
		ctx contextPkg.Context
	}
	swarmInspectReturns struct {
		result1 swarmPkg.Swarm
		result2 error
	}
	swarmInspectReturnsOnCall map[int]struct {
		result1 swarmPkg.Swarm
		result2 error
	}
	SwarmUpdateStub        func(ctx contextPkg.Context, version swarmPkg.Version, swarm swarmPkg.Spec, flags swarmPkg.UpdateFlags) error
	swarmUpdateMutex       sync.RWMutex
	swarmUpdateArgsForCall []struct {
		ctx     contextPkg.Context
		version swarmPkg.Version
		swarm   swarmPkg.Spec
		flags   swarmPkg.UpdateFlags
	}
	swarmUpdateReturns struct {
		result1 error
	}
	swarmUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	SecretListStub        func(ctx contextPkg.Context, options types.SecretListOptions) ([]swarmPkg.Secret, error)
	secretListMutex       sync.RWMutex
	secretListArgsForCall []struct {
		ctx     contextPkg.Context
		options types.SecretListOptions
	}
	secretListReturns struct {
		result1 []swarmPkg.Secret
		result2 error
	}
	secretListReturnsOnCall map[int]struct {
		result1 []swarmPkg.Secret
		result2 error
	}
	SecretCreateStub        func(ctx contextPkg.Context, secret swarmPkg.SecretSpec) (types.SecretCreateResponse, error)
	secretCreateMutex       sync.RWMutex
	secretCreateArgsForCall []struct {
		ctx    contextPkg.Context
		secret swarmPkg.SecretSpec
	}
	secretCreateReturns struct {
		result1 types.SecretCreateResponse
		result2 error
	}
	secretCreateReturnsOnCall map[int]struct {
		result1 types.SecretCreateResponse
		result2 error
	}
	SecretRemoveStub        func(ctx contextPkg.Context, id string) error
	secretRemoveMutex       sync.RWMutex
	secretRemoveArgsForCall []struct {
		ctx contextPkg.Context
		id  string
	}
	secretRemoveReturns struct {
		result1 error
	}
	secretRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	SecretInspectWithRawStub        func(ctx contextPkg.Context, name string) (swarmPkg.Secret, []byte, error)
	secretInspectWithRawMutex       sync.RWMutex
	secretInspectWithRawArgsForCall []struct {
		ctx  contextPkg.Context
		name string
	}
	secretInspectWithRawReturns struct {
		result1 swarmPkg.Secret
		result2 []byte
		result3 error
	}
	secretInspectWithRawReturnsOnCall map[int]struct {
		result1 swarmPkg.Secret
		result2 []byte
		result3 error
	}
	SecretUpdateStub        func(ctx contextPkg.Context, id string, version swarmPkg.Version, secret swarmPkg.SecretSpec) error
	secretUpdateMutex       sync.RWMutex
	secretUpdateArgsForCall []struct {
		ctx     contextPkg.Context
		id      string
		version swarmPkg.Version
		secret  swarmPkg.SecretSpec
	}
	secretUpdateReturns struct {
		result1 error
	}
	secretUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	EventsStub        func(ctx contextPkg.Context, options types.EventsOptions) (<-chan events.Message, <-chan error)
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		ctx     contextPkg.Context
		options types.EventsOptions
	}
	eventsReturns struct {
		result1 <-chan events.Message
		result2 <-chan error
	}
	eventsReturnsOnCall map[int]struct {
		result1 <-chan events.Message
		result2 <-chan error
	}
	InfoStub        func(ctx contextPkg.Context) (types.Info, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
		ctx contextPkg.Context
	}
	infoReturns struct {
		result1 types.Info
		result2 error
	}
	infoReturnsOnCall map[int]struct {
		result1 types.Info
		result2 error
	}
	RegistryLoginStub        func(ctx contextPkg.Context, auth types.AuthConfig) (registry.AuthenticateOKBody, error)
	registryLoginMutex       sync.RWMutex
	registryLoginArgsForCall []struct {
		ctx  contextPkg.Context
		auth types.AuthConfig
	}
	registryLoginReturns struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}
	registryLoginReturnsOnCall map[int]struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}
	DiskUsageStub        func(ctx contextPkg.Context) (types.DiskUsage, error)
	diskUsageMutex       sync.RWMutex
	diskUsageArgsForCall []struct {
		ctx contextPkg.Context
	}
	diskUsageReturns struct {
		result1 types.DiskUsage
		result2 error
	}
	diskUsageReturnsOnCall map[int]struct {
		result1 types.DiskUsage
		result2 error
	}
	PingStub        func(ctx contextPkg.Context) (types.Ping, error)
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		ctx contextPkg.Context
	}
	pingReturns struct {
		result1 types.Ping
		result2 error
	}
	pingReturnsOnCall map[int]struct {
		result1 types.Ping
		result2 error
	}
	VolumeCreateStub        func(ctx contextPkg.Context, options volumetypes.VolumesCreateBody) (types.Volume, error)
	volumeCreateMutex       sync.RWMutex
	volumeCreateArgsForCall []struct {
		ctx     contextPkg.Context
		options volumetypes.VolumesCreateBody
	}
	volumeCreateReturns struct {
		result1 types.Volume
		result2 error
	}
	volumeCreateReturnsOnCall map[int]struct {
		result1 types.Volume
		result2 error
	}
	VolumeInspectStub        func(ctx contextPkg.Context, volumeID string) (types.Volume, error)
	volumeInspectMutex       sync.RWMutex
	volumeInspectArgsForCall []struct {
		ctx      contextPkg.Context
		volumeID string
	}
	volumeInspectReturns struct {
		result1 types.Volume
		result2 error
	}
	volumeInspectReturnsOnCall map[int]struct {
		result1 types.Volume
		result2 error
	}
	VolumeInspectWithRawStub        func(ctx contextPkg.Context, volumeID string) (types.Volume, []byte, error)
	volumeInspectWithRawMutex       sync.RWMutex
	volumeInspectWithRawArgsForCall []struct {
		ctx      contextPkg.Context
		volumeID string
	}
	volumeInspectWithRawReturns struct {
		result1 types.Volume
		result2 []byte
		result3 error
	}
	volumeInspectWithRawReturnsOnCall map[int]struct {
		result1 types.Volume
		result2 []byte
		result3 error
	}
	VolumeListStub        func(ctx contextPkg.Context, filter filters.Args) (volumetypes.VolumesListOKBody, error)
	volumeListMutex       sync.RWMutex
	volumeListArgsForCall []struct {
		ctx    contextPkg.Context
		filter filters.Args
	}
	volumeListReturns struct {
		result1 volumetypes.VolumesListOKBody
		result2 error
	}
	volumeListReturnsOnCall map[int]struct {
		result1 volumetypes.VolumesListOKBody
		result2 error
	}
	VolumeRemoveStub        func(ctx contextPkg.Context, volumeID string, force bool) error
	volumeRemoveMutex       sync.RWMutex
	volumeRemoveArgsForCall []struct {
		ctx      contextPkg.Context
		volumeID string
		force    bool
	}
	volumeRemoveReturns struct {
		result1 error
	}
	volumeRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	VolumesPruneStub        func(ctx contextPkg.Context, pruneFilter filters.Args) (types.VolumesPruneReport, error)
	volumesPruneMutex       sync.RWMutex
	volumesPruneArgsForCall []struct {
		ctx         contextPkg.Context
		pruneFilter filters.Args
	}
	volumesPruneReturns struct {
		result1 types.VolumesPruneReport
		result2 error
	}
	volumesPruneReturnsOnCall map[int]struct {
		result1 types.VolumesPruneReport
		result2 error
	}
	ClientVersionStub        func() string
	clientVersionMutex       sync.RWMutex
	clientVersionArgsForCall []struct{}
	clientVersionReturns     struct {
		result1 string
	}
	clientVersionReturnsOnCall map[int]struct {
		result1 string
	}
	DaemonHostStub        func() string
	daemonHostMutex       sync.RWMutex
	daemonHostArgsForCall []struct{}
	daemonHostReturns     struct {
		result1 string
	}
	daemonHostReturnsOnCall map[int]struct {
		result1 string
	}
	ServerVersionStub        func(ctx contextPkg.Context) (types.Version, error)
	serverVersionMutex       sync.RWMutex
	serverVersionArgsForCall []struct {
		ctx contextPkg.Context
	}
	serverVersionReturns struct {
		result1 types.Version
		result2 error
	}
	serverVersionReturnsOnCall map[int]struct {
		result1 types.Version
		result2 error
	}
	NegotiateAPIVersionStub        func(ctx contextPkg.Context)
	negotiateAPIVersionMutex       sync.RWMutex
	negotiateAPIVersionArgsForCall []struct {
		ctx contextPkg.Context
	}
	NegotiateAPIVersionPingStub        func(types.Ping)
	negotiateAPIVersionPingMutex       sync.RWMutex
	negotiateAPIVersionPingArgsForCall []struct {
		arg1 types.Ping
	}
	DialSessionStub        func(ctx contextPkg.Context, proto string, meta map[string][]string) (net.Conn, error)
	dialSessionMutex       sync.RWMutex
	dialSessionArgsForCall []struct {
		ctx   contextPkg.Context
		proto string
		meta  map[string][]string
	}
	dialSessionReturns struct {
		result1 net.Conn
		result2 error
	}
	dialSessionReturnsOnCall map[int]struct {
		result1 net.Conn
		result2 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct{}
	closeReturns     struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *fakeDockerClient) ConfigList(ctx contextPkg.Context, options types.ConfigListOptions) ([]swarmPkg.Config, error) {
	fake.configListMutex.Lock()
	ret, specificReturn := fake.configListReturnsOnCall[len(fake.configListArgsForCall)]
	fake.configListArgsForCall = append(fake.configListArgsForCall, struct {
		ctx     contextPkg.Context
		options types.ConfigListOptions
	}{ctx, options})
	fake.recordInvocation("ConfigList", []interface{}{ctx, options})
	fake.configListMutex.Unlock()
	if fake.ConfigListStub != nil {
		return fake.ConfigListStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.configListReturns.result1, fake.configListReturns.result2
}

func (fake *fakeDockerClient) ConfigListCallCount() int {
	fake.configListMutex.RLock()
	defer fake.configListMutex.RUnlock()
	return len(fake.configListArgsForCall)
}

func (fake *fakeDockerClient) ConfigListArgsForCall(i int) (contextPkg.Context, types.ConfigListOptions) {
	fake.configListMutex.RLock()
	defer fake.configListMutex.RUnlock()
	return fake.configListArgsForCall[i].ctx, fake.configListArgsForCall[i].options
}

func (fake *fakeDockerClient) ConfigListReturns(result1 []swarmPkg.Config, result2 error) {
	fake.ConfigListStub = nil
	fake.configListReturns = struct {
		result1 []swarmPkg.Config
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ConfigListReturnsOnCall(i int, result1 []swarmPkg.Config, result2 error) {
	fake.ConfigListStub = nil
	if fake.configListReturnsOnCall == nil {
		fake.configListReturnsOnCall = make(map[int]struct {
			result1 []swarmPkg.Config
			result2 error
		})
	}
	fake.configListReturnsOnCall[i] = struct {
		result1 []swarmPkg.Config
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ConfigCreate(ctx contextPkg.Context, config swarmPkg.ConfigSpec) (types.ConfigCreateResponse, error) {
	fake.configCreateMutex.Lock()
	ret, specificReturn := fake.configCreateReturnsOnCall[len(fake.configCreateArgsForCall)]
	fake.configCreateArgsForCall = append(fake.configCreateArgsForCall, struct {
		ctx    contextPkg.Context
		config swarmPkg.ConfigSpec
	}{ctx, config})
	fake.recordInvocation("ConfigCreate", []interface{}{ctx, config})
	fake.configCreateMutex.Unlock()
	if fake.ConfigCreateStub != nil {
		return fake.ConfigCreateStub(ctx, config)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.configCreateReturns.result1, fake.configCreateReturns.result2
}

func (fake *fakeDockerClient) ConfigCreateCallCount() int {
	fake.configCreateMutex.RLock()
	defer fake.configCreateMutex.RUnlock()
	return len(fake.configCreateArgsForCall)
}

func (fake *fakeDockerClient) ConfigCreateArgsForCall(i int) (contextPkg.Context, swarmPkg.ConfigSpec) {
	fake.configCreateMutex.RLock()
	defer fake.configCreateMutex.RUnlock()
	return fake.configCreateArgsForCall[i].ctx, fake.configCreateArgsForCall[i].config
}

func (fake *fakeDockerClient) ConfigCreateReturns(result1 types.ConfigCreateResponse, result2 error) {
	fake.ConfigCreateStub = nil
	fake.configCreateReturns = struct {
		result1 types.ConfigCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ConfigCreateReturnsOnCall(i int, result1 types.ConfigCreateResponse, result2 error) {
	fake.ConfigCreateStub = nil
	if fake.configCreateReturnsOnCall == nil {
		fake.configCreateReturnsOnCall = make(map[int]struct {
			result1 types.ConfigCreateResponse
			result2 error
		})
	}
	fake.configCreateReturnsOnCall[i] = struct {
		result1 types.ConfigCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ConfigRemove(ctx contextPkg.Context, id string) error {
	fake.configRemoveMutex.Lock()
	ret, specificReturn := fake.configRemoveReturnsOnCall[len(fake.configRemoveArgsForCall)]
	fake.configRemoveArgsForCall = append(fake.configRemoveArgsForCall, struct {
		ctx contextPkg.Context
		id  string
	}{ctx, id})
	fake.recordInvocation("ConfigRemove", []interface{}{ctx, id})
	fake.configRemoveMutex.Unlock()
	if fake.ConfigRemoveStub != nil {
		return fake.ConfigRemoveStub(ctx, id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.configRemoveReturns.result1
}

func (fake *fakeDockerClient) ConfigRemoveCallCount() int {
	fake.configRemoveMutex.RLock()
	defer fake.configRemoveMutex.RUnlock()
	return len(fake.configRemoveArgsForCall)
}

func (fake *fakeDockerClient) ConfigRemoveArgsForCall(i int) (contextPkg.Context, string) {
	fake.configRemoveMutex.RLock()
	defer fake.configRemoveMutex.RUnlock()
	return fake.configRemoveArgsForCall[i].ctx, fake.configRemoveArgsForCall[i].id
}

func (fake *fakeDockerClient) ConfigRemoveReturns(result1 error) {
	fake.ConfigRemoveStub = nil
	fake.configRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ConfigRemoveReturnsOnCall(i int, result1 error) {
	fake.ConfigRemoveStub = nil
	if fake.configRemoveReturnsOnCall == nil {
		fake.configRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.configRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ConfigInspectWithRaw(ctx contextPkg.Context, name string) (swarmPkg.Config, []byte, error) {
	fake.configInspectWithRawMutex.Lock()
	ret, specificReturn := fake.configInspectWithRawReturnsOnCall[len(fake.configInspectWithRawArgsForCall)]
	fake.configInspectWithRawArgsForCall = append(fake.configInspectWithRawArgsForCall, struct {
		ctx  contextPkg.Context
		name string
	}{ctx, name})
	fake.recordInvocation("ConfigInspectWithRaw", []interface{}{ctx, name})
	fake.configInspectWithRawMutex.Unlock()
	if fake.ConfigInspectWithRawStub != nil {
		return fake.ConfigInspectWithRawStub(ctx, name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.configInspectWithRawReturns.result1, fake.configInspectWithRawReturns.result2, fake.configInspectWithRawReturns.result3
}

func (fake *fakeDockerClient) ConfigInspectWithRawCallCount() int {
	fake.configInspectWithRawMutex.RLock()
	defer fake.configInspectWithRawMutex.RUnlock()
	return len(fake.configInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) ConfigInspectWithRawArgsForCall(i int) (contextPkg.Context, string) {
	fake.configInspectWithRawMutex.RLock()
	defer fake.configInspectWithRawMutex.RUnlock()
	return fake.configInspectWithRawArgsForCall[i].ctx, fake.configInspectWithRawArgsForCall[i].name
}

func (fake *fakeDockerClient) ConfigInspectWithRawReturns(result1 swarmPkg.Config, result2 []byte, result3 error) {
	fake.ConfigInspectWithRawStub = nil
	fake.configInspectWithRawReturns = struct {
		result1 swarmPkg.Config
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ConfigInspectWithRawReturnsOnCall(i int, result1 swarmPkg.Config, result2 []byte, result3 error) {
	fake.ConfigInspectWithRawStub = nil
	if fake.configInspectWithRawReturnsOnCall == nil {
		fake.configInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 swarmPkg.Config
			result2 []byte
			result3 error
		})
	}
	fake.configInspectWithRawReturnsOnCall[i] = struct {
		result1 swarmPkg.Config
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ConfigUpdate(ctx contextPkg.Context, id string, version swarmPkg.Version, config swarmPkg.ConfigSpec) error {
	fake.configUpdateMutex.Lock()
	ret, specificReturn := fake.configUpdateReturnsOnCall[len(fake.configUpdateArgsForCall)]
	fake.configUpdateArgsForCall = append(fake.configUpdateArgsForCall, struct {
		ctx     contextPkg.Context
		id      string
		version swarmPkg.Version
		config  swarmPkg.ConfigSpec
	}{ctx, id, version, config})
	fake.recordInvocation("ConfigUpdate", []interface{}{ctx, id, version, config})
	fake.configUpdateMutex.Unlock()
	if fake.ConfigUpdateStub != nil {
		return fake.ConfigUpdateStub(ctx, id, version, config)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.configUpdateReturns.result1
}

func (fake *fakeDockerClient) ConfigUpdateCallCount() int {
	fake.configUpdateMutex.RLock()
	defer fake.configUpdateMutex.RUnlock()
	return len(fake.configUpdateArgsForCall)
}

func (fake *fakeDockerClient) ConfigUpdateArgsForCall(i int) (contextPkg.Context, string, swarmPkg.Version, swarmPkg.ConfigSpec) {
	fake.configUpdateMutex.RLock()
	defer fake.configUpdateMutex.RUnlock()
	return fake.configUpdateArgsForCall[i].ctx, fake.configUpdateArgsForCall[i].id, fake.configUpdateArgsForCall[i].version, fake.configUpdateArgsForCall[i].config
}

func (fake *fakeDockerClient) ConfigUpdateReturns(result1 error) {
	fake.ConfigUpdateStub = nil
	fake.configUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ConfigUpdateReturnsOnCall(i int, result1 error) {
	fake.ConfigUpdateStub = nil
	if fake.configUpdateReturnsOnCall == nil {
		fake.configUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.configUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerAttach(ctx contextPkg.Context, container string, options types.ContainerAttachOptions) (types.HijackedResponse, error) {
	fake.containerAttachMutex.Lock()
	ret, specificReturn := fake.containerAttachReturnsOnCall[len(fake.containerAttachArgsForCall)]
	fake.containerAttachArgsForCall = append(fake.containerAttachArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		options   types.ContainerAttachOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerAttach", []interface{}{ctx, container, options})
	fake.containerAttachMutex.Unlock()
	if fake.ContainerAttachStub != nil {
		return fake.ContainerAttachStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerAttachReturns.result1, fake.containerAttachReturns.result2
}

func (fake *fakeDockerClient) ContainerAttachCallCount() int {
	fake.containerAttachMutex.RLock()
	defer fake.containerAttachMutex.RUnlock()
	return len(fake.containerAttachArgsForCall)
}

func (fake *fakeDockerClient) ContainerAttachArgsForCall(i int) (contextPkg.Context, string, types.ContainerAttachOptions) {
	fake.containerAttachMutex.RLock()
	defer fake.containerAttachMutex.RUnlock()
	return fake.containerAttachArgsForCall[i].ctx, fake.containerAttachArgsForCall[i].container, fake.containerAttachArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerAttachReturns(result1 types.HijackedResponse, result2 error) {
	fake.ContainerAttachStub = nil
	fake.containerAttachReturns = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerAttachReturnsOnCall(i int, result1 types.HijackedResponse, result2 error) {
	fake.ContainerAttachStub = nil
	if fake.containerAttachReturnsOnCall == nil {
		fake.containerAttachReturnsOnCall = make(map[int]struct {
			result1 types.HijackedResponse
			result2 error
		})
	}
	fake.containerAttachReturnsOnCall[i] = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerCommit(ctx contextPkg.Context, container string, options types.ContainerCommitOptions) (types.IDResponse, error) {
	fake.containerCommitMutex.Lock()
	ret, specificReturn := fake.containerCommitReturnsOnCall[len(fake.containerCommitArgsForCall)]
	fake.containerCommitArgsForCall = append(fake.containerCommitArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		options   types.ContainerCommitOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerCommit", []interface{}{ctx, container, options})
	fake.containerCommitMutex.Unlock()
	if fake.ContainerCommitStub != nil {
		return fake.ContainerCommitStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerCommitReturns.result1, fake.containerCommitReturns.result2
}

func (fake *fakeDockerClient) ContainerCommitCallCount() int {
	fake.containerCommitMutex.RLock()
	defer fake.containerCommitMutex.RUnlock()
	return len(fake.containerCommitArgsForCall)
}

func (fake *fakeDockerClient) ContainerCommitArgsForCall(i int) (contextPkg.Context, string, types.ContainerCommitOptions) {
	fake.containerCommitMutex.RLock()
	defer fake.containerCommitMutex.RUnlock()
	return fake.containerCommitArgsForCall[i].ctx, fake.containerCommitArgsForCall[i].container, fake.containerCommitArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerCommitReturns(result1 types.IDResponse, result2 error) {
	fake.ContainerCommitStub = nil
	fake.containerCommitReturns = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerCommitReturnsOnCall(i int, result1 types.IDResponse, result2 error) {
	fake.ContainerCommitStub = nil
	if fake.containerCommitReturnsOnCall == nil {
		fake.containerCommitReturnsOnCall = make(map[int]struct {
			result1 types.IDResponse
			result2 error
		})
	}
	fake.containerCommitReturnsOnCall[i] = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerCreate(ctx contextPkg.Context, config *containertypes.Config, hostConfig *containertypes.HostConfig, networkingConfig *networktypes.NetworkingConfig, containerName string) (containertypes.ContainerCreateCreatedBody, error) {
	fake.containerCreateMutex.Lock()
	ret, specificReturn := fake.containerCreateReturnsOnCall[len(fake.containerCreateArgsForCall)]
	fake.containerCreateArgsForCall = append(fake.containerCreateArgsForCall, struct {
		ctx              contextPkg.Context
		config           *containertypes.Config
		hostConfig       *containertypes.HostConfig
		networkingConfig *networktypes.NetworkingConfig
		containerName    string
	}{ctx, config, hostConfig, networkingConfig, containerName})
	fake.recordInvocation("ContainerCreate", []interface{}{ctx, config, hostConfig, networkingConfig, containerName})
	fake.containerCreateMutex.Unlock()
	if fake.ContainerCreateStub != nil {
		return fake.ContainerCreateStub(ctx, config, hostConfig, networkingConfig, containerName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerCreateReturns.result1, fake.containerCreateReturns.result2
}

func (fake *fakeDockerClient) ContainerCreateCallCount() int {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return len(fake.containerCreateArgsForCall)
}

func (fake *fakeDockerClient) ContainerCreateArgsForCall(i int) (contextPkg.Context, *containertypes.Config, *containertypes.HostConfig, *networktypes.NetworkingConfig, string) {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return fake.containerCreateArgsForCall[i].ctx, fake.containerCreateArgsForCall[i].config, fake.containerCreateArgsForCall[i].hostConfig, fake.containerCreateArgsForCall[i].networkingConfig, fake.containerCreateArgsForCall[i].containerName
}

func (fake *fakeDockerClient) ContainerCreateReturns(result1 containertypes.ContainerCreateCreatedBody, result2 error) {
	fake.ContainerCreateStub = nil
	fake.containerCreateReturns = struct {
		result1 containertypes.ContainerCreateCreatedBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerCreateReturnsOnCall(i int, result1 containertypes.ContainerCreateCreatedBody, result2 error) {
	fake.ContainerCreateStub = nil
	if fake.containerCreateReturnsOnCall == nil {
		fake.containerCreateReturnsOnCall = make(map[int]struct {
			result1 containertypes.ContainerCreateCreatedBody
			result2 error
		})
	}
	fake.containerCreateReturnsOnCall[i] = struct {
		result1 containertypes.ContainerCreateCreatedBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerDiff(ctx contextPkg.Context, container string) ([]containertypes.ContainerChangeResponseItem, error) {
	fake.containerDiffMutex.Lock()
	ret, specificReturn := fake.containerDiffReturnsOnCall[len(fake.containerDiffArgsForCall)]
	fake.containerDiffArgsForCall = append(fake.containerDiffArgsForCall, struct {
		ctx       contextPkg.Context
		container string
	}{ctx, container})
	fake.recordInvocation("ContainerDiff", []interface{}{ctx, container})
	fake.containerDiffMutex.Unlock()
	if fake.ContainerDiffStub != nil {
		return fake.ContainerDiffStub(ctx, container)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerDiffReturns.result1, fake.containerDiffReturns.result2
}

func (fake *fakeDockerClient) ContainerDiffCallCount() int {
	fake.containerDiffMutex.RLock()
	defer fake.containerDiffMutex.RUnlock()
	return len(fake.containerDiffArgsForCall)
}

func (fake *fakeDockerClient) ContainerDiffArgsForCall(i int) (contextPkg.Context, string) {
	fake.containerDiffMutex.RLock()
	defer fake.containerDiffMutex.RUnlock()
	return fake.containerDiffArgsForCall[i].ctx, fake.containerDiffArgsForCall[i].container
}

func (fake *fakeDockerClient) ContainerDiffReturns(result1 []containertypes.ContainerChangeResponseItem, result2 error) {
	fake.ContainerDiffStub = nil
	fake.containerDiffReturns = struct {
		result1 []containertypes.ContainerChangeResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerDiffReturnsOnCall(i int, result1 []containertypes.ContainerChangeResponseItem, result2 error) {
	fake.ContainerDiffStub = nil
	if fake.containerDiffReturnsOnCall == nil {
		fake.containerDiffReturnsOnCall = make(map[int]struct {
			result1 []containertypes.ContainerChangeResponseItem
			result2 error
		})
	}
	fake.containerDiffReturnsOnCall[i] = struct {
		result1 []containertypes.ContainerChangeResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecAttach(ctx contextPkg.Context, execID string, config types.ExecStartCheck) (types.HijackedResponse, error) {
	fake.containerExecAttachMutex.Lock()
	ret, specificReturn := fake.containerExecAttachReturnsOnCall[len(fake.containerExecAttachArgsForCall)]
	fake.containerExecAttachArgsForCall = append(fake.containerExecAttachArgsForCall, struct {
		ctx    contextPkg.Context
		execID string
		config types.ExecStartCheck
	}{ctx, execID, config})
	fake.recordInvocation("ContainerExecAttach", []interface{}{ctx, execID, config})
	fake.containerExecAttachMutex.Unlock()
	if fake.ContainerExecAttachStub != nil {
		return fake.ContainerExecAttachStub(ctx, execID, config)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerExecAttachReturns.result1, fake.containerExecAttachReturns.result2
}

func (fake *fakeDockerClient) ContainerExecAttachCallCount() int {
	fake.containerExecAttachMutex.RLock()
	defer fake.containerExecAttachMutex.RUnlock()
	return len(fake.containerExecAttachArgsForCall)
}

func (fake *fakeDockerClient) ContainerExecAttachArgsForCall(i int) (contextPkg.Context, string, types.ExecStartCheck) {
	fake.containerExecAttachMutex.RLock()
	defer fake.containerExecAttachMutex.RUnlock()
	return fake.containerExecAttachArgsForCall[i].ctx, fake.containerExecAttachArgsForCall[i].execID, fake.containerExecAttachArgsForCall[i].config
}

func (fake *fakeDockerClient) ContainerExecAttachReturns(result1 types.HijackedResponse, result2 error) {
	fake.ContainerExecAttachStub = nil
	fake.containerExecAttachReturns = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecAttachReturnsOnCall(i int, result1 types.HijackedResponse, result2 error) {
	fake.ContainerExecAttachStub = nil
	if fake.containerExecAttachReturnsOnCall == nil {
		fake.containerExecAttachReturnsOnCall = make(map[int]struct {
			result1 types.HijackedResponse
			result2 error
		})
	}
	fake.containerExecAttachReturnsOnCall[i] = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecCreate(ctx contextPkg.Context, container string, config types.ExecConfig) (types.IDResponse, error) {
	fake.containerExecCreateMutex.Lock()
	ret, specificReturn := fake.containerExecCreateReturnsOnCall[len(fake.containerExecCreateArgsForCall)]
	fake.containerExecCreateArgsForCall = append(fake.containerExecCreateArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		config    types.ExecConfig
	}{ctx, container, config})
	fake.recordInvocation("ContainerExecCreate", []interface{}{ctx, container, config})
	fake.containerExecCreateMutex.Unlock()
	if fake.ContainerExecCreateStub != nil {
		return fake.ContainerExecCreateStub(ctx, container, config)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerExecCreateReturns.result1, fake.containerExecCreateReturns.result2
}

func (fake *fakeDockerClient) ContainerExecCreateCallCount() int {
	fake.containerExecCreateMutex.RLock()
	defer fake.containerExecCreateMutex.RUnlock()
	return len(fake.containerExecCreateArgsForCall)
}

func (fake *fakeDockerClient) ContainerExecCreateArgsForCall(i int) (contextPkg.Context, string, types.ExecConfig) {
	fake.containerExecCreateMutex.RLock()
	defer fake.containerExecCreateMutex.RUnlock()
	return fake.containerExecCreateArgsForCall[i].ctx, fake.containerExecCreateArgsForCall[i].container, fake.containerExecCreateArgsForCall[i].config
}

func (fake *fakeDockerClient) ContainerExecCreateReturns(result1 types.IDResponse, result2 error) {
	fake.ContainerExecCreateStub = nil
	fake.containerExecCreateReturns = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecCreateReturnsOnCall(i int, result1 types.IDResponse, result2 error) {
	fake.ContainerExecCreateStub = nil
	if fake.containerExecCreateReturnsOnCall == nil {
		fake.containerExecCreateReturnsOnCall = make(map[int]struct {
			result1 types.IDResponse
			result2 error
		})
	}
	fake.containerExecCreateReturnsOnCall[i] = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecInspect(ctx contextPkg.Context, execID string) (types.ContainerExecInspect, error) {
	fake.containerExecInspectMutex.Lock()
	ret, specificReturn := fake.containerExecInspectReturnsOnCall[len(fake.containerExecInspectArgsForCall)]
	fake.containerExecInspectArgsForCall = append(fake.containerExecInspectArgsForCall, struct {
		ctx    contextPkg.Context
		execID string
	}{ctx, execID})
	fake.recordInvocation("ContainerExecInspect", []interface{}{ctx, execID})
	fake.containerExecInspectMutex.Unlock()
	if fake.ContainerExecInspectStub != nil {
		return fake.ContainerExecInspectStub(ctx, execID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerExecInspectReturns.result1, fake.containerExecInspectReturns.result2
}

func (fake *fakeDockerClient) ContainerExecInspectCallCount() int {
	fake.containerExecInspectMutex.RLock()
	defer fake.containerExecInspectMutex.RUnlock()
	return len(fake.containerExecInspectArgsForCall)
}

func (fake *fakeDockerClient) ContainerExecInspectArgsForCall(i int) (contextPkg.Context, string) {
	fake.containerExecInspectMutex.RLock()
	defer fake.containerExecInspectMutex.RUnlock()
	return fake.containerExecInspectArgsForCall[i].ctx, fake.containerExecInspectArgsForCall[i].execID
}

func (fake *fakeDockerClient) ContainerExecInspectReturns(result1 types.ContainerExecInspect, result2 error) {
	fake.ContainerExecInspectStub = nil
	fake.containerExecInspectReturns = struct {
		result1 types.ContainerExecInspect
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecInspectReturnsOnCall(i int, result1 types.ContainerExecInspect, result2 error) {
	fake.ContainerExecInspectStub = nil
	if fake.containerExecInspectReturnsOnCall == nil {
		fake.containerExecInspectReturnsOnCall = make(map[int]struct {
			result1 types.ContainerExecInspect
			result2 error
		})
	}
	fake.containerExecInspectReturnsOnCall[i] = struct {
		result1 types.ContainerExecInspect
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecResize(ctx contextPkg.Context, execID string, options types.ResizeOptions) error {
	fake.containerExecResizeMutex.Lock()
	ret, specificReturn := fake.containerExecResizeReturnsOnCall[len(fake.containerExecResizeArgsForCall)]
	fake.containerExecResizeArgsForCall = append(fake.containerExecResizeArgsForCall, struct {
		ctx     contextPkg.Context
		execID  string
		options types.ResizeOptions
	}{ctx, execID, options})
	fake.recordInvocation("ContainerExecResize", []interface{}{ctx, execID, options})
	fake.containerExecResizeMutex.Unlock()
	if fake.ContainerExecResizeStub != nil {
		return fake.ContainerExecResizeStub(ctx, execID, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerExecResizeReturns.result1
}

func (fake *fakeDockerClient) ContainerExecResizeCallCount() int {
	fake.containerExecResizeMutex.RLock()
	defer fake.containerExecResizeMutex.RUnlock()
	return len(fake.containerExecResizeArgsForCall)
}

func (fake *fakeDockerClient) ContainerExecResizeArgsForCall(i int) (contextPkg.Context, string, types.ResizeOptions) {
	fake.containerExecResizeMutex.RLock()
	defer fake.containerExecResizeMutex.RUnlock()
	return fake.containerExecResizeArgsForCall[i].ctx, fake.containerExecResizeArgsForCall[i].execID, fake.containerExecResizeArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerExecResizeReturns(result1 error) {
	fake.ContainerExecResizeStub = nil
	fake.containerExecResizeReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerExecResizeReturnsOnCall(i int, result1 error) {
	fake.ContainerExecResizeStub = nil
	if fake.containerExecResizeReturnsOnCall == nil {
		fake.containerExecResizeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerExecResizeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerExecStart(ctx contextPkg.Context, execID string, config types.ExecStartCheck) error {
	fake.containerExecStartMutex.Lock()
	ret, specificReturn := fake.containerExecStartReturnsOnCall[len(fake.containerExecStartArgsForCall)]
	fake.containerExecStartArgsForCall = append(fake.containerExecStartArgsForCall, struct {
		ctx    contextPkg.Context
		execID string
		config types.ExecStartCheck
	}{ctx, execID, config})
	fake.recordInvocation("ContainerExecStart", []interface{}{ctx, execID, config})
	fake.containerExecStartMutex.Unlock()
	if fake.ContainerExecStartStub != nil {
		return fake.ContainerExecStartStub(ctx, execID, config)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerExecStartReturns.result1
}

func (fake *fakeDockerClient) ContainerExecStartCallCount() int {
	fake.containerExecStartMutex.RLock()
	defer fake.containerExecStartMutex.RUnlock()
	return len(fake.containerExecStartArgsForCall)
}

func (fake *fakeDockerClient) ContainerExecStartArgsForCall(i int) (contextPkg.Context, string, types.ExecStartCheck) {
	fake.containerExecStartMutex.RLock()
	defer fake.containerExecStartMutex.RUnlock()
	return fake.containerExecStartArgsForCall[i].ctx, fake.containerExecStartArgsForCall[i].execID, fake.containerExecStartArgsForCall[i].config
}

func (fake *fakeDockerClient) ContainerExecStartReturns(result1 error) {
	fake.ContainerExecStartStub = nil
	fake.containerExecStartReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerExecStartReturnsOnCall(i int, result1 error) {
	fake.ContainerExecStartStub = nil
	if fake.containerExecStartReturnsOnCall == nil {
		fake.containerExecStartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerExecStartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerExport(ctx contextPkg.Context, container string) (io.ReadCloser, error) {
	fake.containerExportMutex.Lock()
	ret, specificReturn := fake.containerExportReturnsOnCall[len(fake.containerExportArgsForCall)]
	fake.containerExportArgsForCall = append(fake.containerExportArgsForCall, struct {
		ctx       contextPkg.Context
		container string
	}{ctx, container})
	fake.recordInvocation("ContainerExport", []interface{}{ctx, container})
	fake.containerExportMutex.Unlock()
	if fake.ContainerExportStub != nil {
		return fake.ContainerExportStub(ctx, container)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerExportReturns.result1, fake.containerExportReturns.result2
}

func (fake *fakeDockerClient) ContainerExportCallCount() int {
	fake.containerExportMutex.RLock()
	defer fake.containerExportMutex.RUnlock()
	return len(fake.containerExportArgsForCall)
}

func (fake *fakeDockerClient) ContainerExportArgsForCall(i int) (contextPkg.Context, string) {
	fake.containerExportMutex.RLock()
	defer fake.containerExportMutex.RUnlock()
	return fake.containerExportArgsForCall[i].ctx, fake.containerExportArgsForCall[i].container
}

func (fake *fakeDockerClient) ContainerExportReturns(result1 io.ReadCloser, result2 error) {
	fake.ContainerExportStub = nil
	fake.containerExportReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExportReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ContainerExportStub = nil
	if fake.containerExportReturnsOnCall == nil {
		fake.containerExportReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.containerExportReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerInspect(ctx contextPkg.Context, container string) (types.ContainerJSON, error) {
	fake.containerInspectMutex.Lock()
	ret, specificReturn := fake.containerInspectReturnsOnCall[len(fake.containerInspectArgsForCall)]
	fake.containerInspectArgsForCall = append(fake.containerInspectArgsForCall, struct {
		ctx       contextPkg.Context
		container string
	}{ctx, container})
	fake.recordInvocation("ContainerInspect", []interface{}{ctx, container})
	fake.containerInspectMutex.Unlock()
	if fake.ContainerInspectStub != nil {
		return fake.ContainerInspectStub(ctx, container)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerInspectReturns.result1, fake.containerInspectReturns.result2
}

func (fake *fakeDockerClient) ContainerInspectCallCount() int {
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	return len(fake.containerInspectArgsForCall)
}

func (fake *fakeDockerClient) ContainerInspectArgsForCall(i int) (contextPkg.Context, string) {
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	return fake.containerInspectArgsForCall[i].ctx, fake.containerInspectArgsForCall[i].container
}

func (fake *fakeDockerClient) ContainerInspectReturns(result1 types.ContainerJSON, result2 error) {
	fake.ContainerInspectStub = nil
	fake.containerInspectReturns = struct {
		result1 types.ContainerJSON
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerInspectReturnsOnCall(i int, result1 types.ContainerJSON, result2 error) {
	fake.ContainerInspectStub = nil
	if fake.containerInspectReturnsOnCall == nil {
		fake.containerInspectReturnsOnCall = make(map[int]struct {
			result1 types.ContainerJSON
			result2 error
		})
	}
	fake.containerInspectReturnsOnCall[i] = struct {
		result1 types.ContainerJSON
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerInspectWithRaw(ctx contextPkg.Context, container string, getSize bool) (types.ContainerJSON, []byte, error) {
	fake.containerInspectWithRawMutex.Lock()
	ret, specificReturn := fake.containerInspectWithRawReturnsOnCall[len(fake.containerInspectWithRawArgsForCall)]
	fake.containerInspectWithRawArgsForCall = append(fake.containerInspectWithRawArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		getSize   bool
	}{ctx, container, getSize})
	fake.recordInvocation("ContainerInspectWithRaw", []interface{}{ctx, container, getSize})
	fake.containerInspectWithRawMutex.Unlock()
	if fake.ContainerInspectWithRawStub != nil {
		return fake.ContainerInspectWithRawStub(ctx, container, getSize)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.containerInspectWithRawReturns.result1, fake.containerInspectWithRawReturns.result2, fake.containerInspectWithRawReturns.result3
}

func (fake *fakeDockerClient) ContainerInspectWithRawCallCount() int {
	fake.containerInspectWithRawMutex.RLock()
	defer fake.containerInspectWithRawMutex.RUnlock()
	return len(fake.containerInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) ContainerInspectWithRawArgsForCall(i int) (contextPkg.Context, string, bool) {
	fake.containerInspectWithRawMutex.RLock()
	defer fake.containerInspectWithRawMutex.RUnlock()
	return fake.containerInspectWithRawArgsForCall[i].ctx, fake.containerInspectWithRawArgsForCall[i].container, fake.containerInspectWithRawArgsForCall[i].getSize
}

func (fake *fakeDockerClient) ContainerInspectWithRawReturns(result1 types.ContainerJSON, result2 []byte, result3 error) {
	fake.ContainerInspectWithRawStub = nil
	fake.containerInspectWithRawReturns = struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ContainerInspectWithRawReturnsOnCall(i int, result1 types.ContainerJSON, result2 []byte, result3 error) {
	fake.ContainerInspectWithRawStub = nil
	if fake.containerInspectWithRawReturnsOnCall == nil {
		fake.containerInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 types.ContainerJSON
			result2 []byte
			result3 error
		})
	}
	fake.containerInspectWithRawReturnsOnCall[i] = struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ContainerKill(ctx contextPkg.Context, container string, signal string) error {
	fake.containerKillMutex.Lock()
	ret, specificReturn := fake.containerKillReturnsOnCall[len(fake.containerKillArgsForCall)]
	fake.containerKillArgsForCall = append(fake.containerKillArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		signal    string
	}{ctx, container, signal})
	fake.recordInvocation("ContainerKill", []interface{}{ctx, container, signal})
	fake.containerKillMutex.Unlock()
	if fake.ContainerKillStub != nil {
		return fake.ContainerKillStub(ctx, container, signal)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerKillReturns.result1
}

func (fake *fakeDockerClient) ContainerKillCallCount() int {
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	return len(fake.containerKillArgsForCall)
}

func (fake *fakeDockerClient) ContainerKillArgsForCall(i int) (contextPkg.Context, string, string) {
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	return fake.containerKillArgsForCall[i].ctx, fake.containerKillArgsForCall[i].container, fake.containerKillArgsForCall[i].signal
}

func (fake *fakeDockerClient) ContainerKillReturns(result1 error) {
	fake.ContainerKillStub = nil
	fake.containerKillReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerKillReturnsOnCall(i int, result1 error) {
	fake.ContainerKillStub = nil
	if fake.containerKillReturnsOnCall == nil {
		fake.containerKillReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerKillReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerList(ctx contextPkg.Context, options types.ContainerListOptions) ([]types.Container, error) {
	fake.containerListMutex.Lock()
	ret, specificReturn := fake.containerListReturnsOnCall[len(fake.containerListArgsForCall)]
	fake.containerListArgsForCall = append(fake.containerListArgsForCall, struct {
		ctx     contextPkg.Context
		options types.ContainerListOptions
	}{ctx, options})
	fake.recordInvocation("ContainerList", []interface{}{ctx, options})
	fake.containerListMutex.Unlock()
	if fake.ContainerListStub != nil {
		return fake.ContainerListStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerListReturns.result1, fake.containerListReturns.result2
}

func (fake *fakeDockerClient) ContainerListCallCount() int {
	fake.containerListMutex.RLock()
	defer fake.containerListMutex.RUnlock()
	return len(fake.containerListArgsForCall)
}

func (fake *fakeDockerClient) ContainerListArgsForCall(i int) (contextPkg.Context, types.ContainerListOptions) {
	fake.containerListMutex.RLock()
	defer fake.containerListMutex.RUnlock()
	return fake.containerListArgsForCall[i].ctx, fake.containerListArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerListReturns(result1 []types.Container, result2 error) {
	fake.ContainerListStub = nil
	fake.containerListReturns = struct {
		result1 []types.Container
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerListReturnsOnCall(i int, result1 []types.Container, result2 error) {
	fake.ContainerListStub = nil
	if fake.containerListReturnsOnCall == nil {
		fake.containerListReturnsOnCall = make(map[int]struct {
			result1 []types.Container
			result2 error
		})
	}
	fake.containerListReturnsOnCall[i] = struct {
		result1 []types.Container
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerLogs(ctx contextPkg.Context, container string, options types.ContainerLogsOptions) (io.ReadCloser, error) {
	fake.containerLogsMutex.Lock()
	ret, specificReturn := fake.containerLogsReturnsOnCall[len(fake.containerLogsArgsForCall)]
	fake.containerLogsArgsForCall = append(fake.containerLogsArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		options   types.ContainerLogsOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerLogs", []interface{}{ctx, container, options})
	fake.containerLogsMutex.Unlock()
	if fake.ContainerLogsStub != nil {
		return fake.ContainerLogsStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerLogsReturns.result1, fake.containerLogsReturns.result2
}

func (fake *fakeDockerClient) ContainerLogsCallCount() int {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return len(fake.containerLogsArgsForCall)
}

func (fake *fakeDockerClient) ContainerLogsArgsForCall(i int) (contextPkg.Context, string, types.ContainerLogsOptions) {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return fake.containerLogsArgsForCall[i].ctx, fake.containerLogsArgsForCall[i].container, fake.containerLogsArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.ContainerLogsStub = nil
	fake.containerLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerLogsReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ContainerLogsStub = nil
	if fake.containerLogsReturnsOnCall == nil {
		fake.containerLogsReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.containerLogsReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerPause(ctx contextPkg.Context, container string) error {
	fake.containerPauseMutex.Lock()
	ret, specificReturn := fake.containerPauseReturnsOnCall[len(fake.containerPauseArgsForCall)]
	fake.containerPauseArgsForCall = append(fake.containerPauseArgsForCall, struct {
		ctx       contextPkg.Context
		container string
	}{ctx, container})
	fake.recordInvocation("ContainerPause", []interface{}{ctx, container})
	fake.containerPauseMutex.Unlock()
	if fake.ContainerPauseStub != nil {
		return fake.ContainerPauseStub(ctx, container)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerPauseReturns.result1
}

func (fake *fakeDockerClient) ContainerPauseCallCount() int {
	fake.containerPauseMutex.RLock()
	defer fake.containerPauseMutex.RUnlock()
	return len(fake.containerPauseArgsForCall)
}

func (fake *fakeDockerClient) ContainerPauseArgsForCall(i int) (contextPkg.Context, string) {
	fake.containerPauseMutex.RLock()
	defer fake.containerPauseMutex.RUnlock()
	return fake.containerPauseArgsForCall[i].ctx, fake.containerPauseArgsForCall[i].container
}

func (fake *fakeDockerClient) ContainerPauseReturns(result1 error) {
	fake.ContainerPauseStub = nil
	fake.containerPauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerPauseReturnsOnCall(i int, result1 error) {
	fake.ContainerPauseStub = nil
	if fake.containerPauseReturnsOnCall == nil {
		fake.containerPauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerPauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRemove(ctx contextPkg.Context, container string, options types.ContainerRemoveOptions) error {
	fake.containerRemoveMutex.Lock()
	ret, specificReturn := fake.containerRemoveReturnsOnCall[len(fake.containerRemoveArgsForCall)]
	fake.containerRemoveArgsForCall = append(fake.containerRemoveArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		options   types.ContainerRemoveOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerRemove", []interface{}{ctx, container, options})
	fake.containerRemoveMutex.Unlock()
	if fake.ContainerRemoveStub != nil {
		return fake.ContainerRemoveStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerRemoveReturns.result1
}

func (fake *fakeDockerClient) ContainerRemoveCallCount() int {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return len(fake.containerRemoveArgsForCall)
}

func (fake *fakeDockerClient) ContainerRemoveArgsForCall(i int) (contextPkg.Context, string, types.ContainerRemoveOptions) {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return fake.containerRemoveArgsForCall[i].ctx, fake.containerRemoveArgsForCall[i].container, fake.containerRemoveArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerRemoveReturns(result1 error) {
	fake.ContainerRemoveStub = nil
	fake.containerRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRemoveReturnsOnCall(i int, result1 error) {
	fake.ContainerRemoveStub = nil
	if fake.containerRemoveReturnsOnCall == nil {
		fake.containerRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRename(ctx contextPkg.Context, container string, newContainerName string) error {
	fake.containerRenameMutex.Lock()
	ret, specificReturn := fake.containerRenameReturnsOnCall[len(fake.containerRenameArgsForCall)]
	fake.containerRenameArgsForCall = append(fake.containerRenameArgsForCall, struct {
		ctx              contextPkg.Context
		container        string
		newContainerName string
	}{ctx, container, newContainerName})
	fake.recordInvocation("ContainerRename", []interface{}{ctx, container, newContainerName})
	fake.containerRenameMutex.Unlock()
	if fake.ContainerRenameStub != nil {
		return fake.ContainerRenameStub(ctx, container, newContainerName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerRenameReturns.result1
}

func (fake *fakeDockerClient) ContainerRenameCallCount() int {
	fake.containerRenameMutex.RLock()
	defer fake.containerRenameMutex.RUnlock()
	return len(fake.containerRenameArgsForCall)
}

func (fake *fakeDockerClient) ContainerRenameArgsForCall(i int) (contextPkg.Context, string, string) {
	fake.containerRenameMutex.RLock()
	defer fake.containerRenameMutex.RUnlock()
	return fake.containerRenameArgsForCall[i].ctx, fake.containerRenameArgsForCall[i].container, fake.containerRenameArgsForCall[i].newContainerName
}

func (fake *fakeDockerClient) ContainerRenameReturns(result1 error) {
	fake.ContainerRenameStub = nil
	fake.containerRenameReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRenameReturnsOnCall(i int, result1 error) {
	fake.ContainerRenameStub = nil
	if fake.containerRenameReturnsOnCall == nil {
		fake.containerRenameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRenameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerResize(ctx contextPkg.Context, container string, options types.ResizeOptions) error {
	fake.containerResizeMutex.Lock()
	ret, specificReturn := fake.containerResizeReturnsOnCall[len(fake.containerResizeArgsForCall)]
	fake.containerResizeArgsForCall = append(fake.containerResizeArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		options   types.ResizeOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerResize", []interface{}{ctx, container, options})
	fake.containerResizeMutex.Unlock()
	if fake.ContainerResizeStub != nil {
		return fake.ContainerResizeStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerResizeReturns.result1
}

func (fake *fakeDockerClient) ContainerResizeCallCount() int {
	fake.containerResizeMutex.RLock()
	defer fake.containerResizeMutex.RUnlock()
	return len(fake.containerResizeArgsForCall)
}

func (fake *fakeDockerClient) ContainerResizeArgsForCall(i int) (contextPkg.Context, string, types.ResizeOptions) {
	fake.containerResizeMutex.RLock()
	defer fake.containerResizeMutex.RUnlock()
	return fake.containerResizeArgsForCall[i].ctx, fake.containerResizeArgsForCall[i].container, fake.containerResizeArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerResizeReturns(result1 error) {
	fake.ContainerResizeStub = nil
	fake.containerResizeReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerResizeReturnsOnCall(i int, result1 error) {
	fake.ContainerResizeStub = nil
	if fake.containerResizeReturnsOnCall == nil {
		fake.containerResizeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerResizeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRestart(ctx contextPkg.Context, container string, timeout *time.Duration) error {
	fake.containerRestartMutex.Lock()
	ret, specificReturn := fake.containerRestartReturnsOnCall[len(fake.containerRestartArgsForCall)]
	fake.containerRestartArgsForCall = append(fake.containerRestartArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		timeout   *time.Duration
	}{ctx, container, timeout})
	fake.recordInvocation("ContainerRestart", []interface{}{ctx, container, timeout})
	fake.containerRestartMutex.Unlock()
	if fake.ContainerRestartStub != nil {
		return fake.ContainerRestartStub(ctx, container, timeout)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerRestartReturns.result1
}

func (fake *fakeDockerClient) ContainerRestartCallCount() int {
	fake.containerRestartMutex.RLock()
	defer fake.containerRestartMutex.RUnlock()
	return len(fake.containerRestartArgsForCall)
}

func (fake *fakeDockerClient) ContainerRestartArgsForCall(i int) (contextPkg.Context, string, *time.Duration) {
	fake.containerRestartMutex.RLock()
	defer fake.containerRestartMutex.RUnlock()
	return fake.containerRestartArgsForCall[i].ctx, fake.containerRestartArgsForCall[i].container, fake.containerRestartArgsForCall[i].timeout
}

func (fake *fakeDockerClient) ContainerRestartReturns(result1 error) {
	fake.ContainerRestartStub = nil
	fake.containerRestartReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRestartReturnsOnCall(i int, result1 error) {
	fake.ContainerRestartStub = nil
	if fake.containerRestartReturnsOnCall == nil {
		fake.containerRestartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRestartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStatPath(ctx contextPkg.Context, container string, path string) (types.ContainerPathStat, error) {
	fake.containerStatPathMutex.Lock()
	ret, specificReturn := fake.containerStatPathReturnsOnCall[len(fake.containerStatPathArgsForCall)]
	fake.containerStatPathArgsForCall = append(fake.containerStatPathArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		path      string
	}{ctx, container, path})
	fake.recordInvocation("ContainerStatPath", []interface{}{ctx, container, path})
	fake.containerStatPathMutex.Unlock()
	if fake.ContainerStatPathStub != nil {
		return fake.ContainerStatPathStub(ctx, container, path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerStatPathReturns.result1, fake.containerStatPathReturns.result2
}

func (fake *fakeDockerClient) ContainerStatPathCallCount() int {
	fake.containerStatPathMutex.RLock()
	defer fake.containerStatPathMutex.RUnlock()
	return len(fake.containerStatPathArgsForCall)
}

func (fake *fakeDockerClient) ContainerStatPathArgsForCall(i int) (contextPkg.Context, string, string) {
	fake.containerStatPathMutex.RLock()
	defer fake.containerStatPathMutex.RUnlock()
	return fake.containerStatPathArgsForCall[i].ctx, fake.containerStatPathArgsForCall[i].container, fake.containerStatPathArgsForCall[i].path
}

func (fake *fakeDockerClient) ContainerStatPathReturns(result1 types.ContainerPathStat, result2 error) {
	fake.ContainerStatPathStub = nil
	fake.containerStatPathReturns = struct {
		result1 types.ContainerPathStat
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerStatPathReturnsOnCall(i int, result1 types.ContainerPathStat, result2 error) {
	fake.ContainerStatPathStub = nil
	if fake.containerStatPathReturnsOnCall == nil {
		fake.containerStatPathReturnsOnCall = make(map[int]struct {
			result1 types.ContainerPathStat
			result2 error
		})
	}
	fake.containerStatPathReturnsOnCall[i] = struct {
		result1 types.ContainerPathStat
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerStats(ctx contextPkg.Context, container string, stream bool) (types.ContainerStats, error) {
	fake.containerStatsMutex.Lock()
	ret, specificReturn := fake.containerStatsReturnsOnCall[len(fake.containerStatsArgsForCall)]
	fake.containerStatsArgsForCall = append(fake.containerStatsArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		stream    bool
	}{ctx, container, stream})
	fake.recordInvocation("ContainerStats", []interface{}{ctx, container, stream})
	fake.containerStatsMutex.Unlock()
	if fake.ContainerStatsStub != nil {
		return fake.ContainerStatsStub(ctx, container, stream)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerStatsReturns.result1, fake.containerStatsReturns.result2
}

func (fake *fakeDockerClient) ContainerStatsCallCount() int {
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	return len(fake.containerStatsArgsForCall)
}

func (fake *fakeDockerClient) ContainerStatsArgsForCall(i int) (contextPkg.Context, string, bool) {
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	return fake.containerStatsArgsForCall[i].ctx, fake.containerStatsArgsForCall[i].container, fake.containerStatsArgsForCall[i].stream
}

func (fake *fakeDockerClient) ContainerStatsReturns(result1 types.ContainerStats, result2 error) {
	fake.ContainerStatsStub = nil
	fake.containerStatsReturns = struct {
		result1 types.ContainerStats
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerStatsReturnsOnCall(i int, result1 types.ContainerStats, result2 error) {
	fake.ContainerStatsStub = nil
	if fake.containerStatsReturnsOnCall == nil {
		fake.containerStatsReturnsOnCall = make(map[int]struct {
			result1 types.ContainerStats
			result2 error
		})
	}
	fake.containerStatsReturnsOnCall[i] = struct {
		result1 types.ContainerStats
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerStart(ctx contextPkg.Context, container string, options types.ContainerStartOptions) error {
	fake.containerStartMutex.Lock()
	ret, specificReturn := fake.containerStartReturnsOnCall[len(fake.containerStartArgsForCall)]
	fake.containerStartArgsForCall = append(fake.containerStartArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		options   types.ContainerStartOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerStart", []interface{}{ctx, container, options})
	fake.containerStartMutex.Unlock()
	if fake.ContainerStartStub != nil {
		return fake.ContainerStartStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerStartReturns.result1
}

func (fake *fakeDockerClient) ContainerStartCallCount() int {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return len(fake.containerStartArgsForCall)
}

func (fake *fakeDockerClient) ContainerStartArgsForCall(i int) (contextPkg.Context, string, types.ContainerStartOptions) {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return fake.containerStartArgsForCall[i].ctx, fake.containerStartArgsForCall[i].container, fake.containerStartArgsForCall[i].options
}

func (fake *fakeDockerClient) ContainerStartReturns(result1 error) {
	fake.ContainerStartStub = nil
	fake.containerStartReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStartReturnsOnCall(i int, result1 error) {
	fake.ContainerStartStub = nil
	if fake.containerStartReturnsOnCall == nil {
		fake.containerStartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStop(ctx contextPkg.Context, container string, timeout *time.Duration) error {
	fake.containerStopMutex.Lock()
	ret, specificReturn := fake.containerStopReturnsOnCall[len(fake.containerStopArgsForCall)]
	fake.containerStopArgsForCall = append(fake.containerStopArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		timeout   *time.Duration
	}{ctx, container, timeout})
	fake.recordInvocation("ContainerStop", []interface{}{ctx, container, timeout})
	fake.containerStopMutex.Unlock()
	if fake.ContainerStopStub != nil {
		return fake.ContainerStopStub(ctx, container, timeout)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerStopReturns.result1
}

func (fake *fakeDockerClient) ContainerStopCallCount() int {
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	return len(fake.containerStopArgsForCall)
}

func (fake *fakeDockerClient) ContainerStopArgsForCall(i int) (contextPkg.Context, string, *time.Duration) {
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	return fake.containerStopArgsForCall[i].ctx, fake.containerStopArgsForCall[i].container, fake.containerStopArgsForCall[i].timeout
}

func (fake *fakeDockerClient) ContainerStopReturns(result1 error) {
	fake.ContainerStopStub = nil
	fake.containerStopReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStopReturnsOnCall(i int, result1 error) {
	fake.ContainerStopStub = nil
	if fake.containerStopReturnsOnCall == nil {
		fake.containerStopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerTop(ctx contextPkg.Context, container string, arguments []string) (containertypes.ContainerTopOKBody, error) {
	var argumentsCopy []string
	if arguments != nil {
		argumentsCopy = make([]string, len(arguments))
		copy(argumentsCopy, arguments)
	}
	fake.containerTopMutex.Lock()
	ret, specificReturn := fake.containerTopReturnsOnCall[len(fake.containerTopArgsForCall)]
	fake.containerTopArgsForCall = append(fake.containerTopArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		arguments []string
	}{ctx, container, argumentsCopy})
	fake.recordInvocation("ContainerTop", []interface{}{ctx, container, argumentsCopy})
	fake.containerTopMutex.Unlock()
	if fake.ContainerTopStub != nil {
		return fake.ContainerTopStub(ctx, container, arguments)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerTopReturns.result1, fake.containerTopReturns.result2
}

func (fake *fakeDockerClient) ContainerTopCallCount() int {
	fake.containerTopMutex.RLock()
	defer fake.containerTopMutex.RUnlock()
	return len(fake.containerTopArgsForCall)
}

func (fake *fakeDockerClient) ContainerTopArgsForCall(i int) (contextPkg.Context, string, []string) {
	fake.containerTopMutex.RLock()
	defer fake.containerTopMutex.RUnlock()
	return fake.containerTopArgsForCall[i].ctx, fake.containerTopArgsForCall[i].container, fake.containerTopArgsForCall[i].arguments
}

func (fake *fakeDockerClient) ContainerTopReturns(result1 containertypes.ContainerTopOKBody, result2 error) {
	fake.ContainerTopStub = nil
	fake.containerTopReturns = struct {
		result1 containertypes.ContainerTopOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerTopReturnsOnCall(i int, result1 containertypes.ContainerTopOKBody, result2 error) {
	fake.ContainerTopStub = nil
	if fake.containerTopReturnsOnCall == nil {
		fake.containerTopReturnsOnCall = make(map[int]struct {
			result1 containertypes.ContainerTopOKBody
			result2 error
		})
	}
	fake.containerTopReturnsOnCall[i] = struct {
		result1 containertypes.ContainerTopOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerUnpause(ctx contextPkg.Context, container string) error {
	fake.containerUnpauseMutex.Lock()
	ret, specificReturn := fake.containerUnpauseReturnsOnCall[len(fake.containerUnpauseArgsForCall)]
	fake.containerUnpauseArgsForCall = append(fake.containerUnpauseArgsForCall, struct {
		ctx       contextPkg.Context
		container string
	}{ctx, container})
	fake.recordInvocation("ContainerUnpause", []interface{}{ctx, container})
	fake.containerUnpauseMutex.Unlock()
	if fake.ContainerUnpauseStub != nil {
		return fake.ContainerUnpauseStub(ctx, container)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerUnpauseReturns.result1
}

func (fake *fakeDockerClient) ContainerUnpauseCallCount() int {
	fake.containerUnpauseMutex.RLock()
	defer fake.containerUnpauseMutex.RUnlock()
	return len(fake.containerUnpauseArgsForCall)
}

func (fake *fakeDockerClient) ContainerUnpauseArgsForCall(i int) (contextPkg.Context, string) {
	fake.containerUnpauseMutex.RLock()
	defer fake.containerUnpauseMutex.RUnlock()
	return fake.containerUnpauseArgsForCall[i].ctx, fake.containerUnpauseArgsForCall[i].container
}

func (fake *fakeDockerClient) ContainerUnpauseReturns(result1 error) {
	fake.ContainerUnpauseStub = nil
	fake.containerUnpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerUnpauseReturnsOnCall(i int, result1 error) {
	fake.ContainerUnpauseStub = nil
	if fake.containerUnpauseReturnsOnCall == nil {
		fake.containerUnpauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerUnpauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerUpdate(ctx contextPkg.Context, container string, updateConfig containertypes.UpdateConfig) (containertypes.ContainerUpdateOKBody, error) {
	fake.containerUpdateMutex.Lock()
	ret, specificReturn := fake.containerUpdateReturnsOnCall[len(fake.containerUpdateArgsForCall)]
	fake.containerUpdateArgsForCall = append(fake.containerUpdateArgsForCall, struct {
		ctx          contextPkg.Context
		container    string
		updateConfig containertypes.UpdateConfig
	}{ctx, container, updateConfig})
	fake.recordInvocation("ContainerUpdate", []interface{}{ctx, container, updateConfig})
	fake.containerUpdateMutex.Unlock()
	if fake.ContainerUpdateStub != nil {
		return fake.ContainerUpdateStub(ctx, container, updateConfig)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerUpdateReturns.result1, fake.containerUpdateReturns.result2
}

func (fake *fakeDockerClient) ContainerUpdateCallCount() int {
	fake.containerUpdateMutex.RLock()
	defer fake.containerUpdateMutex.RUnlock()
	return len(fake.containerUpdateArgsForCall)
}

func (fake *fakeDockerClient) ContainerUpdateArgsForCall(i int) (contextPkg.Context, string, containertypes.UpdateConfig) {
	fake.containerUpdateMutex.RLock()
	defer fake.containerUpdateMutex.RUnlock()
	return fake.containerUpdateArgsForCall[i].ctx, fake.containerUpdateArgsForCall[i].container, fake.containerUpdateArgsForCall[i].updateConfig
}

func (fake *fakeDockerClient) ContainerUpdateReturns(result1 containertypes.ContainerUpdateOKBody, result2 error) {
	fake.ContainerUpdateStub = nil
	fake.containerUpdateReturns = struct {
		result1 containertypes.ContainerUpdateOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerUpdateReturnsOnCall(i int, result1 containertypes.ContainerUpdateOKBody, result2 error) {
	fake.ContainerUpdateStub = nil
	if fake.containerUpdateReturnsOnCall == nil {
		fake.containerUpdateReturnsOnCall = make(map[int]struct {
			result1 containertypes.ContainerUpdateOKBody
			result2 error
		})
	}
	fake.containerUpdateReturnsOnCall[i] = struct {
		result1 containertypes.ContainerUpdateOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerWait(ctx contextPkg.Context, container string, condition containertypes.WaitCondition) (<-chan containertypes.ContainerWaitOKBody, <-chan error) {
	fake.containerWaitMutex.Lock()
	ret, specificReturn := fake.containerWaitReturnsOnCall[len(fake.containerWaitArgsForCall)]
	fake.containerWaitArgsForCall = append(fake.containerWaitArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		condition containertypes.WaitCondition
	}{ctx, container, condition})
	fake.recordInvocation("ContainerWait", []interface{}{ctx, container, condition})
	fake.containerWaitMutex.Unlock()
	if fake.ContainerWaitStub != nil {
		return fake.ContainerWaitStub(ctx, container, condition)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerWaitReturns.result1, fake.containerWaitReturns.result2
}

func (fake *fakeDockerClient) ContainerWaitCallCount() int {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return len(fake.containerWaitArgsForCall)
}

func (fake *fakeDockerClient) ContainerWaitArgsForCall(i int) (contextPkg.Context, string, containertypes.WaitCondition) {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return fake.containerWaitArgsForCall[i].ctx, fake.containerWaitArgsForCall[i].container, fake.containerWaitArgsForCall[i].condition
}

func (fake *fakeDockerClient) ContainerWaitReturns(result1 <-chan containertypes.ContainerWaitOKBody, result2 <-chan error) {
	fake.ContainerWaitStub = nil
	fake.containerWaitReturns = struct {
		result1 <-chan containertypes.ContainerWaitOKBody
		result2 <-chan error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerWaitReturnsOnCall(i int, result1 <-chan containertypes.ContainerWaitOKBody, result2 <-chan error) {
	fake.ContainerWaitStub = nil
	if fake.containerWaitReturnsOnCall == nil {
		fake.containerWaitReturnsOnCall = make(map[int]struct {
			result1 <-chan containertypes.ContainerWaitOKBody
			result2 <-chan error
		})
	}
	fake.containerWaitReturnsOnCall[i] = struct {
		result1 <-chan containertypes.ContainerWaitOKBody
		result2 <-chan error
	}{result1, result2}
}

func (fake *fakeDockerClient) CopyFromContainer(ctx contextPkg.Context, container string, srcPath string) (io.ReadCloser, types.ContainerPathStat, error) {
	fake.copyFromContainerMutex.Lock()
	ret, specificReturn := fake.copyFromContainerReturnsOnCall[len(fake.copyFromContainerArgsForCall)]
	fake.copyFromContainerArgsForCall = append(fake.copyFromContainerArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		srcPath   string
	}{ctx, container, srcPath})
	fake.recordInvocation("CopyFromContainer", []interface{}{ctx, container, srcPath})
	fake.copyFromContainerMutex.Unlock()
	if fake.CopyFromContainerStub != nil {
		return fake.CopyFromContainerStub(ctx, container, srcPath)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.copyFromContainerReturns.result1, fake.copyFromContainerReturns.result2, fake.copyFromContainerReturns.result3
}

func (fake *fakeDockerClient) CopyFromContainerCallCount() int {
	fake.copyFromContainerMutex.RLock()
	defer fake.copyFromContainerMutex.RUnlock()
	return len(fake.copyFromContainerArgsForCall)
}

func (fake *fakeDockerClient) CopyFromContainerArgsForCall(i int) (contextPkg.Context, string, string) {
	fake.copyFromContainerMutex.RLock()
	defer fake.copyFromContainerMutex.RUnlock()
	return fake.copyFromContainerArgsForCall[i].ctx, fake.copyFromContainerArgsForCall[i].container, fake.copyFromContainerArgsForCall[i].srcPath
}

func (fake *fakeDockerClient) CopyFromContainerReturns(result1 io.ReadCloser, result2 types.ContainerPathStat, result3 error) {
	fake.CopyFromContainerStub = nil
	fake.copyFromContainerReturns = struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) CopyFromContainerReturnsOnCall(i int, result1 io.ReadCloser, result2 types.ContainerPathStat, result3 error) {
	fake.CopyFromContainerStub = nil
	if fake.copyFromContainerReturnsOnCall == nil {
		fake.copyFromContainerReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 types.ContainerPathStat
			result3 error
		})
	}
	fake.copyFromContainerReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) CopyToContainer(ctx contextPkg.Context, container string, path string, content io.Reader, options types.CopyToContainerOptions) error {
	fake.copyToContainerMutex.Lock()
	ret, specificReturn := fake.copyToContainerReturnsOnCall[len(fake.copyToContainerArgsForCall)]
	fake.copyToContainerArgsForCall = append(fake.copyToContainerArgsForCall, struct {
		ctx       contextPkg.Context
		container string
		path      string
		content   io.Reader
		options   types.CopyToContainerOptions
	}{ctx, container, path, content, options})
	fake.recordInvocation("CopyToContainer", []interface{}{ctx, container, path, content, options})
	fake.copyToContainerMutex.Unlock()
	if fake.CopyToContainerStub != nil {
		return fake.CopyToContainerStub(ctx, container, path, content, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.copyToContainerReturns.result1
}

func (fake *fakeDockerClient) CopyToContainerCallCount() int {
	fake.copyToContainerMutex.RLock()
	defer fake.copyToContainerMutex.RUnlock()
	return len(fake.copyToContainerArgsForCall)
}

func (fake *fakeDockerClient) CopyToContainerArgsForCall(i int) (contextPkg.Context, string, string, io.Reader, types.CopyToContainerOptions) {
	fake.copyToContainerMutex.RLock()
	defer fake.copyToContainerMutex.RUnlock()
	return fake.copyToContainerArgsForCall[i].ctx, fake.copyToContainerArgsForCall[i].container, fake.copyToContainerArgsForCall[i].path, fake.copyToContainerArgsForCall[i].content, fake.copyToContainerArgsForCall[i].options
}

func (fake *fakeDockerClient) CopyToContainerReturns(result1 error) {
	fake.CopyToContainerStub = nil
	fake.copyToContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) CopyToContainerReturnsOnCall(i int, result1 error) {
	fake.CopyToContainerStub = nil
	if fake.copyToContainerReturnsOnCall == nil {
		fake.copyToContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copyToContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainersPrune(ctx contextPkg.Context, pruneFilters filters.Args) (types.ContainersPruneReport, error) {
	fake.containersPruneMutex.Lock()
	ret, specificReturn := fake.containersPruneReturnsOnCall[len(fake.containersPruneArgsForCall)]
	fake.containersPruneArgsForCall = append(fake.containersPruneArgsForCall, struct {
		ctx          contextPkg.Context
		pruneFilters filters.Args
	}{ctx, pruneFilters})
	fake.recordInvocation("ContainersPrune", []interface{}{ctx, pruneFilters})
	fake.containersPruneMutex.Unlock()
	if fake.ContainersPruneStub != nil {
		return fake.ContainersPruneStub(ctx, pruneFilters)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containersPruneReturns.result1, fake.containersPruneReturns.result2
}

func (fake *fakeDockerClient) ContainersPruneCallCount() int {
	fake.containersPruneMutex.RLock()
	defer fake.containersPruneMutex.RUnlock()
	return len(fake.containersPruneArgsForCall)
}

func (fake *fakeDockerClient) ContainersPruneArgsForCall(i int) (contextPkg.Context, filters.Args) {
	fake.containersPruneMutex.RLock()
	defer fake.containersPruneMutex.RUnlock()
	return fake.containersPruneArgsForCall[i].ctx, fake.containersPruneArgsForCall[i].pruneFilters
}

func (fake *fakeDockerClient) ContainersPruneReturns(result1 types.ContainersPruneReport, result2 error) {
	fake.ContainersPruneStub = nil
	fake.containersPruneReturns = struct {
		result1 types.ContainersPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainersPruneReturnsOnCall(i int, result1 types.ContainersPruneReport, result2 error) {
	fake.ContainersPruneStub = nil
	if fake.containersPruneReturnsOnCall == nil {
		fake.containersPruneReturnsOnCall = make(map[int]struct {
			result1 types.ContainersPruneReport
			result2 error
		})
	}
	fake.containersPruneReturnsOnCall[i] = struct {
		result1 types.ContainersPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) DistributionInspect(ctx contextPkg.Context, image string, encodedRegistryAuth string) (registry.DistributionInspect, error) {
	fake.distributionInspectMutex.Lock()
	ret, specificReturn := fake.distributionInspectReturnsOnCall[len(fake.distributionInspectArgsForCall)]
	fake.distributionInspectArgsForCall = append(fake.distributionInspectArgsForCall, struct {
		ctx                 contextPkg.Context
		image               string
		encodedRegistryAuth string
	}{ctx, image, encodedRegistryAuth})
	fake.recordInvocation("DistributionInspect", []interface{}{ctx, image, encodedRegistryAuth})
	fake.distributionInspectMutex.Unlock()
	if fake.DistributionInspectStub != nil {
		return fake.DistributionInspectStub(ctx, image, encodedRegistryAuth)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.distributionInspectReturns.result1, fake.distributionInspectReturns.result2
}

func (fake *fakeDockerClient) DistributionInspectCallCount() int {
	fake.distributionInspectMutex.RLock()
	defer fake.distributionInspectMutex.RUnlock()
	return len(fake.distributionInspectArgsForCall)
}

func (fake *fakeDockerClient) DistributionInspectArgsForCall(i int) (contextPkg.Context, string, string) {
	fake.distributionInspectMutex.RLock()
	defer fake.distributionInspectMutex.RUnlock()
	return fake.distributionInspectArgsForCall[i].ctx, fake.distributionInspectArgsForCall[i].image, fake.distributionInspectArgsForCall[i].encodedRegistryAuth
}

func (fake *fakeDockerClient) DistributionInspectReturns(result1 registry.DistributionInspect, result2 error) {
	fake.DistributionInspectStub = nil
	fake.distributionInspectReturns = struct {
		result1 registry.DistributionInspect
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) DistributionInspectReturnsOnCall(i int, result1 registry.DistributionInspect, result2 error) {
	fake.DistributionInspectStub = nil
	if fake.distributionInspectReturnsOnCall == nil {
		fake.distributionInspectReturnsOnCall = make(map[int]struct {
			result1 registry.DistributionInspect
			result2 error
		})
	}
	fake.distributionInspectReturnsOnCall[i] = struct {
		result1 registry.DistributionInspect
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageBuild(ctx contextPkg.Context, context io.Reader, options types.ImageBuildOptions) (types.ImageBuildResponse, error) {
	fake.imageBuildMutex.Lock()
	ret, specificReturn := fake.imageBuildReturnsOnCall[len(fake.imageBuildArgsForCall)]
	fake.imageBuildArgsForCall = append(fake.imageBuildArgsForCall, struct {
		ctx     contextPkg.Context
		context io.Reader
		options types.ImageBuildOptions
	}{ctx, context, options})
	fake.recordInvocation("ImageBuild", []interface{}{ctx, context, options})
	fake.imageBuildMutex.Unlock()
	if fake.ImageBuildStub != nil {
		return fake.ImageBuildStub(ctx, context, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageBuildReturns.result1, fake.imageBuildReturns.result2
}

func (fake *fakeDockerClient) ImageBuildCallCount() int {
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	return len(fake.imageBuildArgsForCall)
}

func (fake *fakeDockerClient) ImageBuildArgsForCall(i int) (contextPkg.Context, io.Reader, types.ImageBuildOptions) {
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	return fake.imageBuildArgsForCall[i].ctx, fake.imageBuildArgsForCall[i].context, fake.imageBuildArgsForCall[i].options
}

func (fake *fakeDockerClient) ImageBuildReturns(result1 types.ImageBuildResponse, result2 error) {
	fake.ImageBuildStub = nil
	fake.imageBuildReturns = struct {
		result1 types.ImageBuildResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageBuildReturnsOnCall(i int, result1 types.ImageBuildResponse, result2 error) {
	fake.ImageBuildStub = nil
	if fake.imageBuildReturnsOnCall == nil {
		fake.imageBuildReturnsOnCall = make(map[int]struct {
			result1 types.ImageBuildResponse
			result2 error
		})
	}
	fake.imageBuildReturnsOnCall[i] = struct {
		result1 types.ImageBuildResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) BuildCachePrune(ctx contextPkg.Context) (*types.BuildCachePruneReport, error) {
	fake.buildCachePruneMutex.Lock()
	ret, specificReturn := fake.buildCachePruneReturnsOnCall[len(fake.buildCachePruneArgsForCall)]
	fake.buildCachePruneArgsForCall = append(fake.buildCachePruneArgsForCall, struct {
		ctx contextPkg.Context
	}{ctx})
	fake.recordInvocation("BuildCachePrune", []interface{}{ctx})
	fake.buildCachePruneMutex.Unlock()
	if fake.BuildCachePruneStub != nil {
		return fake.BuildCachePruneStub(ctx)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.buildCachePruneReturns.result1, fake.buildCachePruneReturns.result2
}

func (fake *fakeDockerClient) BuildCachePruneCallCount() int {
	fake.buildCachePruneMutex.RLock()
	defer fake.buildCachePruneMutex.RUnlock()
	return len(fake.buildCachePruneArgsForCall)
}

func (fake *fakeDockerClient) BuildCachePruneArgsForCall(i int) contextPkg.Context {
	fake.buildCachePruneMutex.RLock()
	defer fake.buildCachePruneMutex.RUnlock()
	return fake.buildCachePruneArgsForCall[i].ctx
}

func (fake *fakeDockerClient) BuildCachePruneReturns(result1 *types.BuildCachePruneReport, result2 error) {
	fake.BuildCachePruneStub = nil
	fake.buildCachePruneReturns = struct {
		result1 *types.BuildCachePruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) BuildCachePruneReturnsOnCall(i int, result1 *types.BuildCachePruneReport, result2 error) {
	fake.BuildCachePruneStub = nil
	if fake.buildCachePruneReturnsOnCall == nil {
		fake.buildCachePruneReturnsOnCall = make(map[int]struct {
			result1 *types.BuildCachePruneReport
			result2 error
		})
	}
	fake.buildCachePruneReturnsOnCall[i] = struct {
		result1 *types.BuildCachePruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageCreate(ctx contextPkg.Context, parentReference string, options types.ImageCreateOptions) (io.ReadCloser, error) {
	fake.imageCreateMutex.Lock()
	ret, specificReturn := fake.imageCreateReturnsOnCall[len(fake.imageCreateArgsForCall)]
	fake.imageCreateArgsForCall = append(fake.imageCreateArgsForCall, struct {
		ctx             contextPkg.Context
		parentReference string
		options         types.ImageCreateOptions
	}{ctx, parentReference, options})
	fake.recordInvocation("ImageCreate", []interface{}{ctx, parentReference, options})
	fake.imageCreateMutex.Unlock()
	if fake.ImageCreateStub != nil {
		return fake.ImageCreateStub(ctx, parentReference, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageCreateReturns.result1, fake.imageCreateReturns.result2
}

func (fake *fakeDockerClient) ImageCreateCallCount() int {
	fake.imageCreateMutex.RLock()
	defer fake.imageCreateMutex.RUnlock()
	return len(fake.imageCreateArgsForCall)
}

func (fake *fakeDockerClient) ImageCreateArgsForCall(i int) (contextPkg.Context, string, types.ImageCreateOptions) {
	fake.imageCreateMutex.RLock()
	defer fake.imageCreateMutex.RUnlock()
	return fake.imageCreateArgsForCall[i].ctx, fake.imageCreateArgsForCall[i].parentReference, fake.imageCreateArgsForCall[i].options
}

func (fake *fakeDockerClient) ImageCreateReturns(result1 io.ReadCloser, result2 error) {
	fake.ImageCreateStub = nil
	fake.imageCreateReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageCreateReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImageCreateStub = nil
	if fake.imageCreateReturnsOnCall == nil {
		fake.imageCreateReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imageCreateReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageHistory(ctx contextPkg.Context, image string) ([]image.HistoryResponseItem, error) {
	fake.imageHistoryMutex.Lock()
	ret, specificReturn := fake.imageHistoryReturnsOnCall[len(fake.imageHistoryArgsForCall)]
	fake.imageHistoryArgsForCall = append(fake.imageHistoryArgsForCall, struct {
		ctx   contextPkg.Context
		image string
	}{ctx, image})
	fake.recordInvocation("ImageHistory", []interface{}{ctx, image})
	fake.imageHistoryMutex.Unlock()
	if fake.ImageHistoryStub != nil {
		return fake.ImageHistoryStub(ctx, image)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageHistoryReturns.result1, fake.imageHistoryReturns.result2
}

func (fake *fakeDockerClient) ImageHistoryCallCount() int {
	fake.imageHistoryMutex.RLock()
	defer fake.imageHistoryMutex.RUnlock()
	return len(fake.imageHistoryArgsForCall)
}

func (fake *fakeDockerClient) ImageHistoryArgsForCall(i int) (contextPkg.Context, string) {
	fake.imageHistoryMutex.RLock()
	defer fake.imageHistoryMutex.RUnlock()
	return fake.imageHistoryArgsForCall[i].ctx, fake.imageHistoryArgsForCall[i].image
}

func (fake *fakeDockerClient) ImageHistoryReturns(result1 []image.HistoryResponseItem, result2 error) {
	fake.ImageHistoryStub = nil
	fake.imageHistoryReturns = struct {
		result1 []image.HistoryResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageHistoryReturnsOnCall(i int, result1 []image.HistoryResponseItem, result2 error) {
	fake.ImageHistoryStub = nil
	if fake.imageHistoryReturnsOnCall == nil {
		fake.imageHistoryReturnsOnCall = make(map[int]struct {
			result1 []image.HistoryResponseItem
			result2 error
		})
	}
	fake.imageHistoryReturnsOnCall[i] = struct {
		result1 []image.HistoryResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageImport(ctx contextPkg.Context, source types.ImageImportSource, ref string, options types.ImageImportOptions) (io.ReadCloser, error) {
	fake.imageImportMutex.Lock()
	ret, specificReturn := fake.imageImportReturnsOnCall[len(fake.imageImportArgsForCall)]
	fake.imageImportArgsForCall = append(fake.imageImportArgsForCall, struct {
		ctx     contextPkg.Context
		source  types.ImageImportSource
		ref     string
		options types.ImageImportOptions
	}{ctx, source, ref, options})
	fake.recordInvocation("ImageImport", []interface{}{ctx, source, ref, options})
	fake.imageImportMutex.Unlock()
	if fake.ImageImportStub != nil {
		return fake.ImageImportStub(ctx, source, ref, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageImportReturns.result1, fake.imageImportReturns.result2
}

func (fake *fakeDockerClient) ImageImportCallCount() int {
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	return len(fake.imageImportArgsForCall)
}

func (fake *fakeDockerClient) ImageImportArgsForCall(i int) (contextPkg.Context, types.ImageImportSource, string, types.ImageImportOptions) {
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	return fake.imageImportArgsForCall[i].ctx, fake.imageImportArgsForCall[i].source, fake.imageImportArgsForCall[i].ref, fake.imageImportArgsForCall[i].options
}

func (fake *fakeDockerClient) ImageImportReturns(result1 io.ReadCloser, result2 error) {
	fake.ImageImportStub = nil
	fake.imageImportReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageImportReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImageImportStub = nil
	if fake.imageImportReturnsOnCall == nil {
		fake.imageImportReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imageImportReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageInspectWithRaw(ctx contextPkg.Context, image string) (types.ImageInspect, []byte, error) {
	fake.imageInspectWithRawMutex.Lock()
	ret, specificReturn := fake.imageInspectWithRawReturnsOnCall[len(fake.imageInspectWithRawArgsForCall)]
	fake.imageInspectWithRawArgsForCall = append(fake.imageInspectWithRawArgsForCall, struct {
		ctx   contextPkg.Context
		image string
	}{ctx, image})
	fake.recordInvocation("ImageInspectWithRaw", []interface{}{ctx, image})
	fake.imageInspectWithRawMutex.Unlock()
	if fake.ImageInspectWithRawStub != nil {
		return fake.ImageInspectWithRawStub(ctx, image)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.imageInspectWithRawReturns.result1, fake.imageInspectWithRawReturns.result2, fake.imageInspectWithRawReturns.result3
}

func (fake *fakeDockerClient) ImageInspectWithRawCallCount() int {
	fake.imageInspectWithRawMutex.RLock()
	defer fake.imageInspectWithRawMutex.RUnlock()
	return len(fake.imageInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) ImageInspectWithRawArgsForCall(i int) (contextPkg.Context, string) {
	fake.imageInspectWithRawMutex.RLock()
	defer fake.imageInspectWithRawMutex.RUnlock()
	return fake.imageInspectWithRawArgsForCall[i].ctx, fake.imageInspectWithRawArgsForCall[i].image
}

func (fake *fakeDockerClient) ImageInspectWithRawReturns(result1 types.ImageInspect, result2 []byte, result3 error) {
	fake.ImageInspectWithRawStub = nil
	fake.imageInspectWithRawReturns = struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ImageInspectWithRawReturnsOnCall(i int, result1 types.ImageInspect, result2 []byte, result3 error) {
	fake.ImageInspectWithRawStub = nil
	if fake.imageInspectWithRawReturnsOnCall == nil {
		fake.imageInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 types.ImageInspect
			result2 []byte
			result3 error
		})
	}
	fake.imageInspectWithRawReturnsOnCall[i] = struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ImageList(ctx contextPkg.Context, options types.ImageListOptions) ([]types.ImageSummary, error) {
	fake.imageListMutex.Lock()
	ret, specificReturn := fake.imageListReturnsOnCall[len(fake.imageListArgsForCall)]
	fake.imageListArgsForCall = append(fake.imageListArgsForCall, struct {
		ctx     contextPkg.Context
		options types.ImageListOptions
	}{ctx, options})
	fake.recordInvocation("ImageList", []interface{}{ctx, options})
	fake.imageListMutex.Unlock()
	if fake.ImageListStub != nil {
		return fake.ImageListStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageListReturns.result1, fake.imageListReturns.result2
}

func (fake *fakeDockerClient) ImageListCallCount() int {
	fake.imageListMutex.RLock()
	defer fake.imageListMutex.RUnlock()
	return len(fake.imageListArgsForCall)
}

func (fake *fakeDockerClient) ImageListArgsForCall(i int) (contextPkg.Context, types.ImageListOptions) {
	fake.imageListMutex.RLock()
	defer fake.imageListMutex.RUnlock()
	return fake.imageListArgsForCall[i].ctx, fake.imageListArgsForCall[i].options
}

func (fake *fakeDockerClient) ImageListReturns(result1 []types.ImageSummary, result2 error) {
	fake.ImageListStub = nil
	fake.imageListReturns = struct {
		result1 []types.ImageSummary
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageListReturnsOnCall(i int, result1 []types.ImageSummary, result2 error) {
	fake.ImageListStub = nil
	if fake.imageListReturnsOnCall == nil {
		fake.imageListReturnsOnCall = make(map[int]struct {
			result1 []types.ImageSummary
			result2 error
		})
	}
	fake.imageListReturnsOnCall[i] = struct {
		result1 []types.ImageSummary
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageLoad(ctx contextPkg.Context, input io.Reader, quiet bool) (types.ImageLoadResponse, error) {
	fake.imageLoadMutex.Lock()
	ret, specificReturn := fake.imageLoadReturnsOnCall[len(fake.imageLoadArgsForCall)]
	fake.imageLoadArgsForCall = append(fake.imageLoadArgsForCall, struct {
		ctx   contextPkg.Context
		input io.Reader
		quiet bool
	}{ctx, input, quiet})
	fake.recordInvocation("ImageLoad", []interface{}{ctx, input, quiet})
	fake.imageLoadMutex.Unlock()
	if fake.ImageLoadStub != nil {
		return fake.ImageLoadStub(ctx, input, quiet)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageLoadReturns.result1, fake.imageLoadReturns.result2
}

func (fake *fakeDockerClient) ImageLoadCallCount() int {
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	return len(fake.imageLoadArgsForCall)
}

func (fake *fakeDockerClient) ImageLoadArgsForCall(i int) (contextPkg.Context, io.Reader, bool) {
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	return fake.imageLoadArgsForCall[i].ctx, fake.imageLoadArgsForCall[i].input, fake.imageLoadArgsForCall[i].quiet
}

func (fake *fakeDockerClient) ImageLoadReturns(result1 types.ImageLoadResponse, result2 error) {
	fake.ImageLoadStub = nil
	fake.imageLoadReturns = struct {
		result1 types.ImageLoadResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageLoadReturnsOnCall(i int, result1 types.ImageLoadResponse, result2 error) {
	fake.ImageLoadStub = nil
	if fake.imageLoadReturnsOnCall == nil {
		fake.imageLoadReturnsOnCall = make(map[int]struct {
			result1 types.ImageLoadResponse
			result2 error
		})
	}
	fake.imageLoadReturnsOnCall[i] = struct {
		result1 types.ImageLoadResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePull(ctx contextPkg.Context, ref string, options types.ImagePullOptions) (io.ReadCloser, error) {
	fake.imagePullMutex.Lock()
	ret, specificReturn := fake.imagePullReturnsOnCall[len(fake.imagePullArgsForCall)]
	fake.imagePullArgsForCall = append(fake.imagePullArgsForCall, struct {
		ctx     contextPkg.Context
		ref     string
		options types.ImagePullOptions
	}{ctx, ref, options})
	fake.recordInvocation("ImagePull", []interface{}{ctx, ref, options})
	fake.imagePullMutex.Unlock()
	if fake.ImagePullStub != nil {
		return fake.ImagePullStub(ctx, ref, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imagePullReturns.result1, fake.imagePullReturns.result2
}

func (fake *fakeDockerClient) ImagePullCallCount() int {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return len(fake.imagePullArgsForCall)
}

func (fake *fakeDockerClient) ImagePullArgsForCall(i int) (contextPkg.Context, string, types.ImagePullOptions) {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return fake.imagePullArgsForCall[i].ctx, fake.imagePullArgsForCall[i].ref, fake.imagePullArgsForCall[i].options
}

func (fake *fakeDockerClient) ImagePullReturns(result1 io.ReadCloser, result2 error) {
	fake.ImagePullStub = nil
	fake.imagePullReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePullReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImagePullStub = nil
	if fake.imagePullReturnsOnCall == nil {
		fake.imagePullReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imagePullReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePush(ctx contextPkg.Context, ref string, options types.ImagePushOptions) (io.ReadCloser, error) {
	fake.imagePushMutex.Lock()
	ret, specificReturn := fake.imagePushReturnsOnCall[len(fake.imagePushArgsForCall)]
	fake.imagePushArgsForCall = append(fake.imagePushArgsForCall, struct {
		ctx     contextPkg.Context
		ref     string
		options types.ImagePushOptions
	}{ctx, ref, options})
	fake.recordInvocation("ImagePush", []interface{}{ctx, ref, options})
	fake.imagePushMutex.Unlock()
	if fake.ImagePushStub != nil {
		return fake.ImagePushStub(ctx, ref, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imagePushReturns.result1, fake.imagePushReturns.result2
}

func (fake *fakeDockerClient) ImagePushCallCount() int {
	fake.imagePushMutex.RLock()
	defer fake.imagePushMutex.RUnlock()
	return len(fake.imagePushArgsForCall)
}

func (fake *fakeDockerClient) ImagePushArgsForCall(i int) (contextPkg.Context, string, types.ImagePushOptions) {
	fake.imagePushMutex.RLock()
	defer fake.imagePushMutex.RUnlock()
	return fake.imagePushArgsForCall[i].ctx, fake.imagePushArgsForCall[i].ref, fake.imagePushArgsForCall[i].options
}

func (fake *fakeDockerClient) ImagePushReturns(result1 io.ReadCloser, result2 error) {
	fake.ImagePushStub = nil
	fake.imagePushReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePushReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImagePushStub = nil
	if fake.imagePushReturnsOnCall == nil {
		fake.imagePushReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imagePushReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageRemove(ctx contextPkg.Context, image string, options types.ImageRemoveOptions) ([]types.ImageDeleteResponseItem, error) {
	fake.imageRemoveMutex.Lock()
	ret, specificReturn := fake.imageRemoveReturnsOnCall[len(fake.imageRemoveArgsForCall)]
	fake.imageRemoveArgsForCall = append(fake.imageRemoveArgsForCall, struct {
		ctx     contextPkg.Context
		image   string
		options types.ImageRemoveOptions
	}{ctx, image, options})
	fake.recordInvocation("ImageRemove", []interface{}{ctx, image, options})
	fake.imageRemoveMutex.Unlock()
	if fake.ImageRemoveStub != nil {
		return fake.ImageRemoveStub(ctx, image, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageRemoveReturns.result1, fake.imageRemoveReturns.result2
}

func (fake *fakeDockerClient) ImageRemoveCallCount() int {
	fake.imageRemoveMutex.RLock()
	defer fake.imageRemoveMutex.RUnlock()
	return len(fake.imageRemoveArgsForCall)
}

func (fake *fakeDockerClient) ImageRemoveArgsForCall(i int) (contextPkg.Context, string, types.ImageRemoveOptions) {
	fake.imageRemoveMutex.RLock()
	defer fake.imageRemoveMutex.RUnlock()
	return fake.imageRemoveArgsForCall[i].ctx, fake.imageRemoveArgsForCall[i].image, fake.imageRemoveArgsForCall[i].options
}

func (fake *fakeDockerClient) ImageRemoveReturns(result1 []types.ImageDeleteResponseItem, result2 error) {
	fake.ImageRemoveStub = nil
	fake.imageRemoveReturns = struct {
		result1 []types.ImageDeleteResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageRemoveReturnsOnCall(i int, result1 []types.ImageDeleteResponseItem, result2 error) {
	fake.ImageRemoveStub = nil
	if fake.imageRemoveReturnsOnCall == nil {
		fake.imageRemoveReturnsOnCall = make(map[int]struct {
			result1 []types.ImageDeleteResponseItem
			result2 error
		})
	}
	fake.imageRemoveReturnsOnCall[i] = struct {
		result1 []types.ImageDeleteResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageSearch(ctx contextPkg.Context, term string, options types.ImageSearchOptions) ([]registry.SearchResult, error) {
	fake.imageSearchMutex.Lock()
	ret, specificReturn := fake.imageSearchReturnsOnCall[len(fake.imageSearchArgsForCall)]
	fake.imageSearchArgsForCall = append(fake.imageSearchArgsForCall, struct {
		ctx     contextPkg.Context
		term    string
		options types.ImageSearchOptions
	}{ctx, term, options})
	fake.recordInvocation("ImageSearch", []interface{}{ctx, term, options})
	fake.imageSearchMutex.Unlock()
	if fake.ImageSearchStub != nil {
		return fake.ImageSearchStub(ctx, term, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageSearchReturns.result1, fake.imageSearchReturns.result2
}

func (fake *fakeDockerClient) ImageSearchCallCount() int {
	fake.imageSearchMutex.RLock()
	defer fake.imageSearchMutex.RUnlock()
	return len(fake.imageSearchArgsForCall)
}

func (fake *fakeDockerClient) ImageSearchArgsForCall(i int) (contextPkg.Context, string, types.ImageSearchOptions) {
	fake.imageSearchMutex.RLock()
	defer fake.imageSearchMutex.RUnlock()
	return fake.imageSearchArgsForCall[i].ctx, fake.imageSearchArgsForCall[i].term, fake.imageSearchArgsForCall[i].options
}

func (fake *fakeDockerClient) ImageSearchReturns(result1 []registry.SearchResult, result2 error) {
	fake.ImageSearchStub = nil
	fake.imageSearchReturns = struct {
		result1 []registry.SearchResult
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageSearchReturnsOnCall(i int, result1 []registry.SearchResult, result2 error) {
	fake.ImageSearchStub = nil
	if fake.imageSearchReturnsOnCall == nil {
		fake.imageSearchReturnsOnCall = make(map[int]struct {
			result1 []registry.SearchResult
			result2 error
		})
	}
	fake.imageSearchReturnsOnCall[i] = struct {
		result1 []registry.SearchResult
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageSave(ctx contextPkg.Context, images []string) (io.ReadCloser, error) {
	var imagesCopy []string
	if images != nil {
		imagesCopy = make([]string, len(images))
		copy(imagesCopy, images)
	}
	fake.imageSaveMutex.Lock()
	ret, specificReturn := fake.imageSaveReturnsOnCall[len(fake.imageSaveArgsForCall)]
	fake.imageSaveArgsForCall = append(fake.imageSaveArgsForCall, struct {
		ctx    contextPkg.Context
		images []string
	}{ctx, imagesCopy})
	fake.recordInvocation("ImageSave", []interface{}{ctx, imagesCopy})
	fake.imageSaveMutex.Unlock()
	if fake.ImageSaveStub != nil {
		return fake.ImageSaveStub(ctx, images)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageSaveReturns.result1, fake.imageSaveReturns.result2
}

func (fake *fakeDockerClient) ImageSaveCallCount() int {
	fake.imageSaveMutex.RLock()
	defer fake.imageSaveMutex.RUnlock()
	return len(fake.imageSaveArgsForCall)
}

func (fake *fakeDockerClient) ImageSaveArgsForCall(i int) (contextPkg.Context, []string) {
	fake.imageSaveMutex.RLock()
	defer fake.imageSaveMutex.RUnlock()
	return fake.imageSaveArgsForCall[i].ctx, fake.imageSaveArgsForCall[i].images
}

func (fake *fakeDockerClient) ImageSaveReturns(result1 io.ReadCloser, result2 error) {
	fake.ImageSaveStub = nil
	fake.imageSaveReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageSaveReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImageSaveStub = nil
	if fake.imageSaveReturnsOnCall == nil {
		fake.imageSaveReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imageSaveReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageTag(ctx contextPkg.Context, image string, ref string) error {
	fake.imageTagMutex.Lock()
	ret, specificReturn := fake.imageTagReturnsOnCall[len(fake.imageTagArgsForCall)]
	fake.imageTagArgsForCall = append(fake.imageTagArgsForCall, struct {
		ctx   contextPkg.Context
		image string
		ref   string
	}{ctx, image, ref})
	fake.recordInvocation("ImageTag", []interface{}{ctx, image, ref})
	fake.imageTagMutex.Unlock()
	if fake.ImageTagStub != nil {
		return fake.ImageTagStub(ctx, image, ref)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.imageTagReturns.result1
}

func (fake *fakeDockerClient) ImageTagCallCount() int {
	fake.imageTagMutex.RLock()
	defer fake.imageTagMutex.RUnlock()
	return len(fake.imageTagArgsForCall)
}

func (fake *fakeDockerClient) ImageTagArgsForCall(i int) (contextPkg.Context, string, string) {
	fake.imageTagMutex.RLock()
	defer fake.imageTagMutex.RUnlock()
	return fake.imageTagArgsForCall[i].ctx, fake.imageTagArgsForCall[i].image, fake.imageTagArgsForCall[i].ref
}

func (fake *fakeDockerClient) ImageTagReturns(result1 error) {
	fake.ImageTagStub = nil
	fake.imageTagReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ImageTagReturnsOnCall(i int, result1 error) {
	fake.ImageTagStub = nil
	if fake.imageTagReturnsOnCall == nil {
		fake.imageTagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.imageTagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ImagesPrune(ctx contextPkg.Context, pruneFilter filters.Args) (types.ImagesPruneReport, error) {
	fake.imagesPruneMutex.Lock()
	ret, specificReturn := fake.imagesPruneReturnsOnCall[len(fake.imagesPruneArgsForCall)]
	fake.imagesPruneArgsForCall = append(fake.imagesPruneArgsForCall, struct {
		ctx         contextPkg.Context
		pruneFilter filters.Args
	}{ctx, pruneFilter})
	fake.recordInvocation("ImagesPrune", []interface{}{ctx, pruneFilter})
	fake.imagesPruneMutex.Unlock()
	if fake.ImagesPruneStub != nil {
		return fake.ImagesPruneStub(ctx, pruneFilter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imagesPruneReturns.result1, fake.imagesPruneReturns.result2
}

func (fake *fakeDockerClient) ImagesPruneCallCount() int {
	fake.imagesPruneMutex.RLock()
	defer fake.imagesPruneMutex.RUnlock()
	return len(fake.imagesPruneArgsForCall)
}

func (fake *fakeDockerClient) ImagesPruneArgsForCall(i int) (contextPkg.Context, filters.Args) {
	fake.imagesPruneMutex.RLock()
	defer fake.imagesPruneMutex.RUnlock()
	return fake.imagesPruneArgsForCall[i].ctx, fake.imagesPruneArgsForCall[i].pruneFilter
}

func (fake *fakeDockerClient) ImagesPruneReturns(result1 types.ImagesPruneReport, result2 error) {
	fake.ImagesPruneStub = nil
	fake.imagesPruneReturns = struct {
		result1 types.ImagesPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagesPruneReturnsOnCall(i int, result1 types.ImagesPruneReport, result2 error) {
	fake.ImagesPruneStub = nil
	if fake.imagesPruneReturnsOnCall == nil {
		fake.imagesPruneReturnsOnCall = make(map[int]struct {
			result1 types.ImagesPruneReport
			result2 error
		})
	}
	fake.imagesPruneReturnsOnCall[i] = struct {
		result1 types.ImagesPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NodeInspectWithRaw(ctx contextPkg.Context, nodeID string) (swarmPkg.Node, []byte, error) {
	fake.nodeInspectWithRawMutex.Lock()
	ret, specificReturn := fake.nodeInspectWithRawReturnsOnCall[len(fake.nodeInspectWithRawArgsForCall)]
	fake.nodeInspectWithRawArgsForCall = append(fake.nodeInspectWithRawArgsForCall, struct {
		ctx    contextPkg.Context
		nodeID string
	}{ctx, nodeID})
	fake.recordInvocation("NodeInspectWithRaw", []interface{}{ctx, nodeID})
	fake.nodeInspectWithRawMutex.Unlock()
	if fake.NodeInspectWithRawStub != nil {
		return fake.NodeInspectWithRawStub(ctx, nodeID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.nodeInspectWithRawReturns.result1, fake.nodeInspectWithRawReturns.result2, fake.nodeInspectWithRawReturns.result3
}

func (fake *fakeDockerClient) NodeInspectWithRawCallCount() int {
	fake.nodeInspectWithRawMutex.RLock()
	defer fake.nodeInspectWithRawMutex.RUnlock()
	return len(fake.nodeInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) NodeInspectWithRawArgsForCall(i int) (contextPkg.Context, string) {
	fake.nodeInspectWithRawMutex.RLock()
	defer fake.nodeInspectWithRawMutex.RUnlock()
	return fake.nodeInspectWithRawArgsForCall[i].ctx, fake.nodeInspectWithRawArgsForCall[i].nodeID
}

func (fake *fakeDockerClient) NodeInspectWithRawReturns(result1 swarmPkg.Node, result2 []byte, result3 error) {
	fake.NodeInspectWithRawStub = nil
	fake.nodeInspectWithRawReturns = struct {
		result1 swarmPkg.Node
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) NodeInspectWithRawReturnsOnCall(i int, result1 swarmPkg.Node, result2 []byte, result3 error) {
	fake.NodeInspectWithRawStub = nil
	if fake.nodeInspectWithRawReturnsOnCall == nil {
		fake.nodeInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 swarmPkg.Node
			result2 []byte
			result3 error
		})
	}
	fake.nodeInspectWithRawReturnsOnCall[i] = struct {
		result1 swarmPkg.Node
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) NodeList(ctx contextPkg.Context, options types.NodeListOptions) ([]swarmPkg.Node, error) {
	fake.nodeListMutex.Lock()
	ret, specificReturn := fake.nodeListReturnsOnCall[len(fake.nodeListArgsForCall)]
	fake.nodeListArgsForCall = append(fake.nodeListArgsForCall, struct {
		ctx     contextPkg.Context
		options types.NodeListOptions
	}{ctx, options})
	fake.recordInvocation("NodeList", []interface{}{ctx, options})
	fake.nodeListMutex.Unlock()
	if fake.NodeListStub != nil {
		return fake.NodeListStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeListReturns.result1, fake.nodeListReturns.result2
}

func (fake *fakeDockerClient) NodeListCallCount() int {
	fake.nodeListMutex.RLock()
	defer fake.nodeListMutex.RUnlock()
	return len(fake.nodeListArgsForCall)
}

func (fake *fakeDockerClient) NodeListArgsForCall(i int) (contextPkg.Context, types.NodeListOptions) {
	fake.nodeListMutex.RLock()
	defer fake.nodeListMutex.RUnlock()
	return fake.nodeListArgsForCall[i].ctx, fake.nodeListArgsForCall[i].options
}

func (fake *fakeDockerClient) NodeListReturns(result1 []swarmPkg.Node, result2 error) {
	fake.NodeListStub = nil
	fake.nodeListReturns = struct {
		result1 []swarmPkg.Node
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NodeListReturnsOnCall(i int, result1 []swarmPkg.Node, result2 error) {
	fake.NodeListStub = nil
	if fake.nodeListReturnsOnCall == nil {
		fake.nodeListReturnsOnCall = make(map[int]struct {
			result1 []swarmPkg.Node
			result2 error
		})
	}
	fake.nodeListReturnsOnCall[i] = struct {
		result1 []swarmPkg.Node
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NodeRemove(ctx contextPkg.Context, nodeID string, options types.NodeRemoveOptions) error {
	fake.nodeRemoveMutex.Lock()
	ret, specificReturn := fake.nodeRemoveReturnsOnCall[len(fake.nodeRemoveArgsForCall)]
	fake.nodeRemoveArgsForCall = append(fake.nodeRemoveArgsForCall, struct {
		ctx     contextPkg.Context
		nodeID  string
		options types.NodeRemoveOptions
	}{ctx, nodeID, options})
	fake.recordInvocation("NodeRemove", []interface{}{ctx, nodeID, options})
	fake.nodeRemoveMutex.Unlock()
	if fake.NodeRemoveStub != nil {
		return fake.NodeRemoveStub(ctx, nodeID, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nodeRemoveReturns.result1
}

func (fake *fakeDockerClient) NodeRemoveCallCount() int {
	fake.nodeRemoveMutex.RLock()
	defer fake.nodeRemoveMutex.RUnlock()
	return len(fake.nodeRemoveArgsForCall)
}

func (fake *fakeDockerClient) NodeRemoveArgsForCall(i int) (contextPkg.Context, string, types.NodeRemoveOptions) {
	fake.nodeRemoveMutex.RLock()
	defer fake.nodeRemoveMutex.RUnlock()
	return fake.nodeRemoveArgsForCall[i].ctx, fake.nodeRemoveArgsForCall[i].nodeID, fake.nodeRemoveArgsForCall[i].options
}

func (fake *fakeDockerClient) NodeRemoveReturns(result1 error) {
	fake.NodeRemoveStub = nil
	fake.nodeRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NodeRemoveReturnsOnCall(i int, result1 error) {
	fake.NodeRemoveStub = nil
	if fake.nodeRemoveReturnsOnCall == nil {
		fake.nodeRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.nodeRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NodeUpdate(ctx contextPkg.Context, nodeID string, version swarmPkg.Version, node swarmPkg.NodeSpec) error {
	fake.nodeUpdateMutex.Lock()
	ret, specificReturn := fake.nodeUpdateReturnsOnCall[len(fake.nodeUpdateArgsForCall)]
	fake.nodeUpdateArgsForCall = append(fake.nodeUpdateArgsForCall, struct {
		ctx     contextPkg.Context
		nodeID  string
		version swarmPkg.Version
		node    swarmPkg.NodeSpec
	}{ctx, nodeID, version, node})
	fake.recordInvocation("NodeUpdate", []interface{}{ctx, nodeID, version, node})
	fake.nodeUpdateMutex.Unlock()
	if fake.NodeUpdateStub != nil {
		return fake.NodeUpdateStub(ctx, nodeID, version, node)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nodeUpdateReturns.result1
}

func (fake *fakeDockerClient) NodeUpdateCallCount() int {
	fake.nodeUpdateMutex.RLock()
	defer fake.nodeUpdateMutex.RUnlock()
	return len(fake.nodeUpdateArgsForCall)
}

func (fake *fakeDockerClient) NodeUpdateArgsForCall(i int) (contextPkg.Context, string, swarmPkg.Version, swarmPkg.NodeSpec) {
	fake.nodeUpdateMutex.RLock()
	defer fake.nodeUpdateMutex.RUnlock()
	return fake.nodeUpdateArgsForCall[i].ctx, fake.nodeUpdateArgsForCall[i].nodeID, fake.nodeUpdateArgsForCall[i].version, fake.nodeUpdateArgsForCall[i].node
}

func (fake *fakeDockerClient) NodeUpdateReturns(result1 error) {
	fake.NodeUpdateStub = nil
	fake.nodeUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NodeUpdateReturnsOnCall(i int, result1 error) {
	fake.NodeUpdateStub = nil
	if fake.nodeUpdateReturnsOnCall == nil {
		fake.nodeUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.nodeUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkConnect(ctx contextPkg.Context, network string, container string, config *networktypes.EndpointSettings) error {
	fake.networkConnectMutex.Lock()
	ret, specificReturn := fake.networkConnectReturnsOnCall[len(fake.networkConnectArgsForCall)]
	fake.networkConnectArgsForCall = append(fake.networkConnectArgsForCall, struct {
		ctx       contextPkg.Context
		network   string
		container string
		config    *networktypes.EndpointSettings
	}{ctx, network, container, config})
	fake.recordInvocation("NetworkConnect", []interface{}{ctx, network, container, config})
	fake.networkConnectMutex.Unlock()
	if fake.NetworkConnectStub != nil {
		return fake.NetworkConnectStub(ctx, network, container, config)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.networkConnectReturns.result1
}

func (fake *fakeDockerClient) NetworkConnectCallCount() int {
	fake.networkConnectMutex.RLock()
	defer fake.networkConnectMutex.RUnlock()
	return len(fake.networkConnectArgsForCall)
}

func (fake *fakeDockerClient) NetworkConnectArgsForCall(i int) (contextPkg.Context, string, string, *networktypes.EndpointSettings) {
	fake.networkConnectMutex.RLock()
	defer fake.networkConnectMutex.RUnlock()
	return fake.networkConnectArgsForCall[i].ctx, fake.networkConnectArgsForCall[i].network, fake.networkConnectArgsForCall[i].container, fake.networkConnectArgsForCall[i].config
}

func (fake *fakeDockerClient) NetworkConnectReturns(result1 error) {
	fake.NetworkConnectStub = nil
	fake.networkConnectReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkConnectReturnsOnCall(i int, result1 error) {
	fake.NetworkConnectStub = nil
	if fake.networkConnectReturnsOnCall == nil {
		fake.networkConnectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.networkConnectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkCreate(ctx contextPkg.Context, name string, options types.NetworkCreate) (types.NetworkCreateResponse, error) {
	fake.networkCreateMutex.Lock()
	ret, specificReturn := fake.networkCreateReturnsOnCall[len(fake.networkCreateArgsForCall)]
	fake.networkCreateArgsForCall = append(fake.networkCreateArgsForCall, struct {
		ctx     contextPkg.Context
		name    string
		options types.NetworkCreate
	}{ctx, name, options})
	fake.recordInvocation("NetworkCreate", []interface{}{ctx, name, options})
	fake.networkCreateMutex.Unlock()
	if fake.NetworkCreateStub != nil {
		return fake.NetworkCreateStub(ctx, name, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.networkCreateReturns.result1, fake.networkCreateReturns.result2
}

func (fake *fakeDockerClient) NetworkCreateCallCount() int {
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	return len(fake.networkCreateArgsForCall)
}

func (fake *fakeDockerClient) NetworkCreateArgsForCall(i int) (contextPkg.Context, string, types.NetworkCreate) {
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	return fake.networkCreateArgsForCall[i].ctx, fake.networkCreateArgsForCall[i].name, fake.networkCreateArgsForCall[i].options
}

func (fake *fakeDockerClient) NetworkCreateReturns(result1 types.NetworkCreateResponse, result2 error) {
	fake.NetworkCreateStub = nil
	fake.networkCreateReturns = struct {
		result1 types.NetworkCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkCreateReturnsOnCall(i int, result1 types.NetworkCreateResponse, result2 error) {
	fake.NetworkCreateStub = nil
	if fake.networkCreateReturnsOnCall == nil {
		fake.networkCreateReturnsOnCall = make(map[int]struct {
			result1 types.NetworkCreateResponse
			result2 error
		})
	}
	fake.networkCreateReturnsOnCall[i] = struct {
		result1 types.NetworkCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkDisconnect(ctx contextPkg.Context, network string, container string, force bool) error {
	fake.networkDisconnectMutex.Lock()
	ret, specificReturn := fake.networkDisconnectReturnsOnCall[len(fake.networkDisconnectArgsForCall)]
	fake.networkDisconnectArgsForCall = append(fake.networkDisconnectArgsForCall, struct {
		ctx       contextPkg.Context
		network   string
		container string
		force     bool
	}{ctx, network, container, force})
	fake.recordInvocation("NetworkDisconnect", []interface{}{ctx, network, container, force})
	fake.networkDisconnectMutex.Unlock()
	if fake.NetworkDisconnectStub != nil {
		return fake.NetworkDisconnectStub(ctx, network, container, force)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.networkDisconnectReturns.result1
}

func (fake *fakeDockerClient) NetworkDisconnectCallCount() int {
	fake.networkDisconnectMutex.RLock()
	defer fake.networkDisconnectMutex.RUnlock()
	return len(fake.networkDisconnectArgsForCall)
}

func (fake *fakeDockerClient) NetworkDisconnectArgsForCall(i int) (contextPkg.Context, string, string, bool) {
	fake.networkDisconnectMutex.RLock()
	defer fake.networkDisconnectMutex.RUnlock()
	return fake.networkDisconnectArgsForCall[i].ctx, fake.networkDisconnectArgsForCall[i].network, fake.networkDisconnectArgsForCall[i].container, fake.networkDisconnectArgsForCall[i].force
}

func (fake *fakeDockerClient) NetworkDisconnectReturns(result1 error) {
	fake.NetworkDisconnectStub = nil
	fake.networkDisconnectReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkDisconnectReturnsOnCall(i int, result1 error) {
	fake.NetworkDisconnectStub = nil
	if fake.networkDisconnectReturnsOnCall == nil {
		fake.networkDisconnectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.networkDisconnectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkInspect(ctx contextPkg.Context, network string, options types.NetworkInspectOptions) (types.NetworkResource, error) {
	fake.networkInspectMutex.Lock()
	ret, specificReturn := fake.networkInspectReturnsOnCall[len(fake.networkInspectArgsForCall)]
	fake.networkInspectArgsForCall = append(fake.networkInspectArgsForCall, struct {
		ctx     contextPkg.Context
		network string
		options types.NetworkInspectOptions
	}{ctx, network, options})
	fake.recordInvocation("NetworkInspect", []interface{}{ctx, network, options})
	fake.networkInspectMutex.Unlock()
	if fake.NetworkInspectStub != nil {
		return fake.NetworkInspectStub(ctx, network, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.networkInspectReturns.result1, fake.networkInspectReturns.result2
}

func (fake *fakeDockerClient) NetworkInspectCallCount() int {
	fake.networkInspectMutex.RLock()
	defer fake.networkInspectMutex.RUnlock()
	return len(fake.networkInspectArgsForCall)
}

func (fake *fakeDockerClient) NetworkInspectArgsForCall(i int) (contextPkg.Context, string, types.NetworkInspectOptions) {
	fake.networkInspectMutex.RLock()
	defer fake.networkInspectMutex.RUnlock()
	return fake.networkInspectArgsForCall[i].ctx, fake.networkInspectArgsForCall[i].network, fake.networkInspectArgsForCall[i].options
}

func (fake *fakeDockerClient) NetworkInspectReturns(result1 types.NetworkResource, result2 error) {
	fake.NetworkInspectStub = nil
	fake.networkInspectReturns = struct {
		result1 types.NetworkResource
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkInspectReturnsOnCall(i int, result1 types.NetworkResource, result2 error) {
	fake.NetworkInspectStub = nil
	if fake.networkInspectReturnsOnCall == nil {
		fake.networkInspectReturnsOnCall = make(map[int]struct {
			result1 types.NetworkResource
			result2 error
		})
	}
	fake.networkInspectReturnsOnCall[i] = struct {
		result1 types.NetworkResource
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkInspectWithRaw(ctx contextPkg.Context, network string, options types.NetworkInspectOptions) (types.NetworkResource, []byte, error) {
	fake.networkInspectWithRawMutex.Lock()
	ret, specificReturn := fake.networkInspectWithRawReturnsOnCall[len(fake.networkInspectWithRawArgsForCall)]
	fake.networkInspectWithRawArgsForCall = append(fake.networkInspectWithRawArgsForCall, struct {
		ctx     contextPkg.Context
		network string
		options types.NetworkInspectOptions
	}{ctx, network, options})
	fake.recordInvocation("NetworkInspectWithRaw", []interface{}{ctx, network, options})
	fake.networkInspectWithRawMutex.Unlock()
	if fake.NetworkInspectWithRawStub != nil {
		return fake.NetworkInspectWithRawStub(ctx, network, options)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.networkInspectWithRawReturns.result1, fake.networkInspectWithRawReturns.result2, fake.networkInspectWithRawReturns.result3
}

func (fake *fakeDockerClient) NetworkInspectWithRawCallCount() int {
	fake.networkInspectWithRawMutex.RLock()
	defer fake.networkInspectWithRawMutex.RUnlock()
	return len(fake.networkInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) NetworkInspectWithRawArgsForCall(i int) (contextPkg.Context, string, types.NetworkInspectOptions) {
	fake.networkInspectWithRawMutex.RLock()
	defer fake.networkInspectWithRawMutex.RUnlock()
	return fake.networkInspectWithRawArgsForCall[i].ctx, fake.networkInspectWithRawArgsForCall[i].network, fake.networkInspectWithRawArgsForCall[i].options
}

func (fake *fakeDockerClient) NetworkInspectWithRawReturns(result1 types.NetworkResource, result2 []byte, result3 error) {
	fake.NetworkInspectWithRawStub = nil
	fake.networkInspectWithRawReturns = struct {
		result1 types.NetworkResource
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) NetworkInspectWithRawReturnsOnCall(i int, result1 types.NetworkResource, result2 []byte, result3 error) {
	fake.NetworkInspectWithRawStub = nil
	if fake.networkInspectWithRawReturnsOnCall == nil {
		fake.networkInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 types.NetworkResource
			result2 []byte
			result3 error
		})
	}
	fake.networkInspectWithRawReturnsOnCall[i] = struct {
		result1 types.NetworkResource
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) NetworkList(ctx contextPkg.Context, options types.NetworkListOptions) ([]types.NetworkResource, error) {
	fake.networkListMutex.Lock()
	ret, specificReturn := fake.networkListReturnsOnCall[len(fake.networkListArgsForCall)]
	fake.networkListArgsForCall = append(fake.networkListArgsForCall, struct {
		ctx     contextPkg.Context
		options types.NetworkListOptions
	}{ctx, options})
	fake.recordInvocation("NetworkList", []interface{}{ctx, options})
	fake.networkListMutex.Unlock()
	if fake.NetworkListStub != nil {
		return fake.NetworkListStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.networkListReturns.result1, fake.networkListReturns.result2
}

func (fake *fakeDockerClient) NetworkListCallCount() int {
	fake.networkListMutex.RLock()
	defer fake.networkListMutex.RUnlock()
	return len(fake.networkListArgsForCall)
}

func (fake *fakeDockerClient) NetworkListArgsForCall(i int) (contextPkg.Context, types.NetworkListOptions) {
	fake.networkListMutex.RLock()
	defer fake.networkListMutex.RUnlock()
	return fake.networkListArgsForCall[i].ctx, fake.networkListArgsForCall[i].options
}

func (fake *fakeDockerClient) NetworkListReturns(result1 []types.NetworkResource, result2 error) {
	fake.NetworkListStub = nil
	fake.networkListReturns = struct {
		result1 []types.NetworkResource
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkListReturnsOnCall(i int, result1 []types.NetworkResource, result2 error) {
	fake.NetworkListStub = nil
	if fake.networkListReturnsOnCall == nil {
		fake.networkListReturnsOnCall = make(map[int]struct {
			result1 []types.NetworkResource
			result2 error
		})
	}
	fake.networkListReturnsOnCall[i] = struct {
		result1 []types.NetworkResource
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkRemove(ctx contextPkg.Context, network string) error {
	fake.networkRemoveMutex.Lock()
	ret, specificReturn := fake.networkRemoveReturnsOnCall[len(fake.networkRemoveArgsForCall)]
	fake.networkRemoveArgsForCall = append(fake.networkRemoveArgsForCall, struct {
		ctx     contextPkg.Context
		network string
	}{ctx, network})
	fake.recordInvocation("NetworkRemove", []interface{}{ctx, network})
	fake.networkRemoveMutex.Unlock()
	if fake.NetworkRemoveStub != nil {
		return fake.NetworkRemoveStub(ctx, network)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.networkRemoveReturns.result1
}

func (fake *fakeDockerClient) NetworkRemoveCallCount() int {
	fake.networkRemoveMutex.RLock()
	defer fake.networkRemoveMutex.RUnlock()
	return len(fake.networkRemoveArgsForCall)
}

func (fake *fakeDockerClient) NetworkRemoveArgsForCall(i int) (contextPkg.Context, string) {
	fake.networkRemoveMutex.RLock()
	defer fake.networkRemoveMutex.RUnlock()
	return fake.networkRemoveArgsForCall[i].ctx, fake.networkRemoveArgsForCall[i].network
}

func (fake *fakeDockerClient) NetworkRemoveReturns(result1 error) {
	fake.NetworkRemoveStub = nil
	fake.networkRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkRemoveReturnsOnCall(i int, result1 error) {
	fake.NetworkRemoveStub = nil
	if fake.networkRemoveReturnsOnCall == nil {
		fake.networkRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.networkRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworksPrune(ctx contextPkg.Context, pruneFilter filters.Args) (types.NetworksPruneReport, error) {
	fake.networksPruneMutex.Lock()
	ret, specificReturn := fake.networksPruneReturnsOnCall[len(fake.networksPruneArgsForCall)]
	fake.networksPruneArgsForCall = append(fake.networksPruneArgsForCall, struct {
		ctx         contextPkg.Context
		pruneFilter filters.Args
	}{ctx, pruneFilter})
	fake.recordInvocation("NetworksPrune", []interface{}{ctx, pruneFilter})
	fake.networksPruneMutex.Unlock()
	if fake.NetworksPruneStub != nil {
		return fake.NetworksPruneStub(ctx, pruneFilter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.networksPruneReturns.result1, fake.networksPruneReturns.result2
}

func (fake *fakeDockerClient) NetworksPruneCallCount() int {
	fake.networksPruneMutex.RLock()
	defer fake.networksPruneMutex.RUnlock()
	return len(fake.networksPruneArgsForCall)
}

func (fake *fakeDockerClient) NetworksPruneArgsForCall(i int) (contextPkg.Context, filters.Args) {
	fake.networksPruneMutex.RLock()
	defer fake.networksPruneMutex.RUnlock()
	return fake.networksPruneArgsForCall[i].ctx, fake.networksPruneArgsForCall[i].pruneFilter
}

func (fake *fakeDockerClient) NetworksPruneReturns(result1 types.NetworksPruneReport, result2 error) {
	fake.NetworksPruneStub = nil
	fake.networksPruneReturns = struct {
		result1 types.NetworksPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworksPruneReturnsOnCall(i int, result1 types.NetworksPruneReport, result2 error) {
	fake.NetworksPruneStub = nil
	if fake.networksPruneReturnsOnCall == nil {
		fake.networksPruneReturnsOnCall = make(map[int]struct {
			result1 types.NetworksPruneReport
			result2 error
		})
	}
	fake.networksPruneReturnsOnCall[i] = struct {
		result1 types.NetworksPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginList(ctx contextPkg.Context, filter filters.Args) (types.PluginsListResponse, error) {
	fake.pluginListMutex.Lock()
	ret, specificReturn := fake.pluginListReturnsOnCall[len(fake.pluginListArgsForCall)]
	fake.pluginListArgsForCall = append(fake.pluginListArgsForCall, struct {
		ctx    contextPkg.Context
		filter filters.Args
	}{ctx, filter})
	fake.recordInvocation("PluginList", []interface{}{ctx, filter})
	fake.pluginListMutex.Unlock()
	if fake.PluginListStub != nil {
		return fake.PluginListStub(ctx, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pluginListReturns.result1, fake.pluginListReturns.result2
}

func (fake *fakeDockerClient) PluginListCallCount() int {
	fake.pluginListMutex.RLock()
	defer fake.pluginListMutex.RUnlock()
	return len(fake.pluginListArgsForCall)
}

func (fake *fakeDockerClient) PluginListArgsForCall(i int) (contextPkg.Context, filters.Args) {
	fake.pluginListMutex.RLock()
	defer fake.pluginListMutex.RUnlock()
	return fake.pluginListArgsForCall[i].ctx, fake.pluginListArgsForCall[i].filter
}

func (fake *fakeDockerClient) PluginListReturns(result1 types.PluginsListResponse, result2 error) {
	fake.PluginListStub = nil
	fake.pluginListReturns = struct {
		result1 types.PluginsListResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginListReturnsOnCall(i int, result1 types.PluginsListResponse, result2 error) {
	fake.PluginListStub = nil
	if fake.pluginListReturnsOnCall == nil {
		fake.pluginListReturnsOnCall = make(map[int]struct {
			result1 types.PluginsListResponse
			result2 error
		})
	}
	fake.pluginListReturnsOnCall[i] = struct {
		result1 types.PluginsListResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginRemove(ctx contextPkg.Context, name string, options types.PluginRemoveOptions) error {
	fake.pluginRemoveMutex.Lock()
	ret, specificReturn := fake.pluginRemoveReturnsOnCall[len(fake.pluginRemoveArgsForCall)]
	fake.pluginRemoveArgsForCall = append(fake.pluginRemoveArgsForCall, struct {
		ctx     contextPkg.Context
		name    string
		options types.PluginRemoveOptions
	}{ctx, name, options})
	fake.recordInvocation("PluginRemove", []interface{}{ctx, name, options})
	fake.pluginRemoveMutex.Unlock()
	if fake.PluginRemoveStub != nil {
		return fake.PluginRemoveStub(ctx, name, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pluginRemoveReturns.result1
}

func (fake *fakeDockerClient) PluginRemoveCallCount() int {
	fake.pluginRemoveMutex.RLock()
	defer fake.pluginRemoveMutex.RUnlock()
	return len(fake.pluginRemoveArgsForCall)
}

func (fake *fakeDockerClient) PluginRemoveArgsForCall(i int) (contextPkg.Context, string, types.PluginRemoveOptions) {
	fake.pluginRemoveMutex.RLock()
	defer fake.pluginRemoveMutex.RUnlock()
	return fake.pluginRemoveArgsForCall[i].ctx, fake.pluginRemoveArgsForCall[i].name, fake.pluginRemoveArgsForCall[i].options
}

func (fake *fakeDockerClient) PluginRemoveReturns(result1 error) {
	fake.PluginRemoveStub = nil
	fake.pluginRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginRemoveReturnsOnCall(i int, result1 error) {
	fake.PluginRemoveStub = nil
	if fake.pluginRemoveReturnsOnCall == nil {
		fake.pluginRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pluginRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginEnable(ctx contextPkg.Context, name string, options types.PluginEnableOptions) error {
	fake.pluginEnableMutex.Lock()
	ret, specificReturn := fake.pluginEnableReturnsOnCall[len(fake.pluginEnableArgsForCall)]
	fake.pluginEnableArgsForCall = append(fake.pluginEnableArgsForCall, struct {
		ctx     contextPkg.Context
		name    string
		options types.PluginEnableOptions
	}{ctx, name, options})
	fake.recordInvocation("PluginEnable", []interface{}{ctx, name, options})
	fake.pluginEnableMutex.Unlock()
	if fake.PluginEnableStub != nil {
		return fake.PluginEnableStub(ctx, name, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pluginEnableReturns.result1
}

func (fake *fakeDockerClient) PluginEnableCallCount() int {
	fake.pluginEnableMutex.RLock()
	defer fake.pluginEnableMutex.RUnlock()
	return len(fake.pluginEnableArgsForCall)
}

func (fake *fakeDockerClient) PluginEnableArgsForCall(i int) (contextPkg.Context, string, types.PluginEnableOptions) {
	fake.pluginEnableMutex.RLock()
	defer fake.pluginEnableMutex.RUnlock()
	return fake.pluginEnableArgsForCall[i].ctx, fake.pluginEnableArgsForCall[i].name, fake.pluginEnableArgsForCall[i].options
}

func (fake *fakeDockerClient) PluginEnableReturns(result1 error) {
	fake.PluginEnableStub = nil
	fake.pluginEnableReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginEnableReturnsOnCall(i int, result1 error) {
	fake.PluginEnableStub = nil
	if fake.pluginEnableReturnsOnCall == nil {
		fake.pluginEnableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pluginEnableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginDisable(ctx contextPkg.Context, name string, options types.PluginDisableOptions) error {
	fake.pluginDisableMutex.Lock()
	ret, specificReturn := fake.pluginDisableReturnsOnCall[len(fake.pluginDisableArgsForCall)]
	fake.pluginDisableArgsForCall = append(fake.pluginDisableArgsForCall, struct {
		ctx     contextPkg.Context
		name    string
		options types.PluginDisableOptions
	}{ctx, name, options})
	fake.recordInvocation("PluginDisable", []interface{}{ctx, name, options})
	fake.pluginDisableMutex.Unlock()
	if fake.PluginDisableStub != nil {
		return fake.PluginDisableStub(ctx, name, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pluginDisableReturns.result1
}

func (fake *fakeDockerClient) PluginDisableCallCount() int {
	fake.pluginDisableMutex.RLock()
	defer fake.pluginDisableMutex.RUnlock()
	return len(fake.pluginDisableArgsForCall)
}

func (fake *fakeDockerClient) PluginDisableArgsForCall(i int) (contextPkg.Context, string, types.PluginDisableOptions) {
	fake.pluginDisableMutex.RLock()
	defer fake.pluginDisableMutex.RUnlock()
	return fake.pluginDisableArgsForCall[i].ctx, fake.pluginDisableArgsForCall[i].name, fake.pluginDisableArgsForCall[i].options
}

func (fake *fakeDockerClient) PluginDisableReturns(result1 error) {
	fake.PluginDisableStub = nil
	fake.pluginDisableReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginDisableReturnsOnCall(i int, result1 error) {
	fake.PluginDisableStub = nil
	if fake.pluginDisableReturnsOnCall == nil {
		fake.pluginDisableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pluginDisableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginInstall(ctx contextPkg.Context, name string, options types.PluginInstallOptions) (io.ReadCloser, error) {
	fake.pluginInstallMutex.Lock()
	ret, specificReturn := fake.pluginInstallReturnsOnCall[len(fake.pluginInstallArgsForCall)]
	fake.pluginInstallArgsForCall = append(fake.pluginInstallArgsForCall, struct {
		ctx     contextPkg.Context
		name    string
		options types.PluginInstallOptions
	}{ctx, name, options})
	fake.recordInvocation("PluginInstall", []interface{}{ctx, name, options})
	fake.pluginInstallMutex.Unlock()
	if fake.PluginInstallStub != nil {
		return fake.PluginInstallStub(ctx, name, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pluginInstallReturns.result1, fake.pluginInstallReturns.result2
}

func (fake *fakeDockerClient) PluginInstallCallCount() int {
	fake.pluginInstallMutex.RLock()
	defer fake.pluginInstallMutex.RUnlock()
	return len(fake.pluginInstallArgsForCall)
}

func (fake *fakeDockerClient) PluginInstallArgsForCall(i int) (contextPkg.Context, string, types.PluginInstallOptions) {
	fake.pluginInstallMutex.RLock()
	defer fake.pluginInstallMutex.RUnlock()
	return fake.pluginInstallArgsForCall[i].ctx, fake.pluginInstallArgsForCall[i].name, fake.pluginInstallArgsForCall[i].options
}

func (fake *fakeDockerClient) PluginInstallReturns(result1 io.ReadCloser, result2 error) {
	fake.PluginInstallStub = nil
	fake.pluginInstallReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginInstallReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.PluginInstallStub = nil
	if fake.pluginInstallReturnsOnCall == nil {
		fake.pluginInstallReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.pluginInstallReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginUpgrade(ctx contextPkg.Context, name string, options types.PluginInstallOptions) (io.ReadCloser, error) {
	fake.pluginUpgradeMutex.Lock()
	ret, specificReturn := fake.pluginUpgradeReturnsOnCall[len(fake.pluginUpgradeArgsForCall)]
	fake.pluginUpgradeArgsForCall = append(fake.pluginUpgradeArgsForCall, struct {
		ctx     contextPkg.Context
		name    string
		options types.PluginInstallOptions
	}{ctx, name, options})
	fake.recordInvocation("PluginUpgrade", []interface{}{ctx, name, options})
	fake.pluginUpgradeMutex.Unlock()
	if fake.PluginUpgradeStub != nil {
		return fake.PluginUpgradeStub(ctx, name, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pluginUpgradeReturns.result1, fake.pluginUpgradeReturns.result2
}

func (fake *fakeDockerClient) PluginUpgradeCallCount() int {
	fake.pluginUpgradeMutex.RLock()
	defer fake.pluginUpgradeMutex.RUnlock()
	return len(fake.pluginUpgradeArgsForCall)
}

func (fake *fakeDockerClient) PluginUpgradeArgsForCall(i int) (contextPkg.Context, string, types.PluginInstallOptions) {
	fake.pluginUpgradeMutex.RLock()
	defer fake.pluginUpgradeMutex.RUnlock()
	return fake.pluginUpgradeArgsForCall[i].ctx, fake.pluginUpgradeArgsForCall[i].name, fake.pluginUpgradeArgsForCall[i].options
}

func (fake *fakeDockerClient) PluginUpgradeReturns(result1 io.ReadCloser, result2 error) {
	fake.PluginUpgradeStub = nil
	fake.pluginUpgradeReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginUpgradeReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.PluginUpgradeStub = nil
	if fake.pluginUpgradeReturnsOnCall == nil {
		fake.pluginUpgradeReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.pluginUpgradeReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginPush(ctx contextPkg.Context, name string, registryAuth string) (io.ReadCloser, error) {
	fake.pluginPushMutex.Lock()
	ret, specificReturn := fake.pluginPushReturnsOnCall[len(fake.pluginPushArgsForCall)]
	fake.pluginPushArgsForCall = append(fake.pluginPushArgsForCall, struct {
		ctx          contextPkg.Context
		name         string
		registryAuth string
	}{ctx, name, registryAuth})
	fake.recordInvocation("PluginPush", []interface{}{ctx, name, registryAuth})
	fake.pluginPushMutex.Unlock()
	if fake.PluginPushStub != nil {
		return fake.PluginPushStub(ctx, name, registryAuth)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pluginPushReturns.result1, fake.pluginPushReturns.result2
}

func (fake *fakeDockerClient) PluginPushCallCount() int {
	fake.pluginPushMutex.RLock()
	defer fake.pluginPushMutex.RUnlock()
	return len(fake.pluginPushArgsForCall)
}

func (fake *fakeDockerClient) PluginPushArgsForCall(i int) (contextPkg.Context, string, string) {
	fake.pluginPushMutex.RLock()
	defer fake.pluginPushMutex.RUnlock()
	return fake.pluginPushArgsForCall[i].ctx, fake.pluginPushArgsForCall[i].name, fake.pluginPushArgsForCall[i].registryAuth
}

func (fake *fakeDockerClient) PluginPushReturns(result1 io.ReadCloser, result2 error) {
	fake.PluginPushStub = nil
	fake.pluginPushReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginPushReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.PluginPushStub = nil
	if fake.pluginPushReturnsOnCall == nil {
		fake.pluginPushReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.pluginPushReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginSet(ctx contextPkg.Context, name string, args []string) error {
	var argsCopy []string
	if args != nil {
		argsCopy = make([]string, len(args))
		copy(argsCopy, args)
	}
	fake.pluginSetMutex.Lock()
	ret, specificReturn := fake.pluginSetReturnsOnCall[len(fake.pluginSetArgsForCall)]
	fake.pluginSetArgsForCall = append(fake.pluginSetArgsForCall, struct {
		ctx  contextPkg.Context
		name string
		args []string
	}{ctx, name, argsCopy})
	fake.recordInvocation("PluginSet", []interface{}{ctx, name, argsCopy})
	fake.pluginSetMutex.Unlock()
	if fake.PluginSetStub != nil {
		return fake.PluginSetStub(ctx, name, args)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pluginSetReturns.result1
}

func (fake *fakeDockerClient) PluginSetCallCount() int {
	fake.pluginSetMutex.RLock()
	defer fake.pluginSetMutex.RUnlock()
	return len(fake.pluginSetArgsForCall)
}

func (fake *fakeDockerClient) PluginSetArgsForCall(i int) (contextPkg.Context, string, []string) {
	fake.pluginSetMutex.RLock()
	defer fake.pluginSetMutex.RUnlock()
	return fake.pluginSetArgsForCall[i].ctx, fake.pluginSetArgsForCall[i].name, fake.pluginSetArgsForCall[i].args
}

func (fake *fakeDockerClient) PluginSetReturns(result1 error) {
	fake.PluginSetStub = nil
	fake.pluginSetReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginSetReturnsOnCall(i int, result1 error) {
	fake.PluginSetStub = nil
	if fake.pluginSetReturnsOnCall == nil {
		fake.pluginSetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pluginSetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginInspectWithRaw(ctx contextPkg.Context, name string) (*types.Plugin, []byte, error) {
	fake.pluginInspectWithRawMutex.Lock()
	ret, specificReturn := fake.pluginInspectWithRawReturnsOnCall[len(fake.pluginInspectWithRawArgsForCall)]
	fake.pluginInspectWithRawArgsForCall = append(fake.pluginInspectWithRawArgsForCall, struct {
		ctx  contextPkg.Context
		name string
	}{ctx, name})
	fake.recordInvocation("PluginInspectWithRaw", []interface{}{ctx, name})
	fake.pluginInspectWithRawMutex.Unlock()
	if fake.PluginInspectWithRawStub != nil {
		return fake.PluginInspectWithRawStub(ctx, name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.pluginInspectWithRawReturns.result1, fake.pluginInspectWithRawReturns.result2, fake.pluginInspectWithRawReturns.result3
}

func (fake *fakeDockerClient) PluginInspectWithRawCallCount() int {
	fake.pluginInspectWithRawMutex.RLock()
	defer fake.pluginInspectWithRawMutex.RUnlock()
	return len(fake.pluginInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) PluginInspectWithRawArgsForCall(i int) (contextPkg.Context, string) {
	fake.pluginInspectWithRawMutex.RLock()
	defer fake.pluginInspectWithRawMutex.RUnlock()
	return fake.pluginInspectWithRawArgsForCall[i].ctx, fake.pluginInspectWithRawArgsForCall[i].name
}

func (fake *fakeDockerClient) PluginInspectWithRawReturns(result1 *types.Plugin, result2 []byte, result3 error) {
	fake.PluginInspectWithRawStub = nil
	fake.pluginInspectWithRawReturns = struct {
		result1 *types.Plugin
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) PluginInspectWithRawReturnsOnCall(i int, result1 *types.Plugin, result2 []byte, result3 error) {
	fake.PluginInspectWithRawStub = nil
	if fake.pluginInspectWithRawReturnsOnCall == nil {
		fake.pluginInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 *types.Plugin
			result2 []byte
			result3 error
		})
	}
	fake.pluginInspectWithRawReturnsOnCall[i] = struct {
		result1 *types.Plugin
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) PluginCreate(ctx contextPkg.Context, createContext io.Reader, options types.PluginCreateOptions) error {
	fake.pluginCreateMutex.Lock()
	ret, specificReturn := fake.pluginCreateReturnsOnCall[len(fake.pluginCreateArgsForCall)]
	fake.pluginCreateArgsForCall = append(fake.pluginCreateArgsForCall, struct {
		ctx           contextPkg.Context
		createContext io.Reader
		options       types.PluginCreateOptions
	}{ctx, createContext, options})
	fake.recordInvocation("PluginCreate", []interface{}{ctx, createContext, options})
	fake.pluginCreateMutex.Unlock()
	if fake.PluginCreateStub != nil {
		return fake.PluginCreateStub(ctx, createContext, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pluginCreateReturns.result1
}

func (fake *fakeDockerClient) PluginCreateCallCount() int {
	fake.pluginCreateMutex.RLock()
	defer fake.pluginCreateMutex.RUnlock()
	return len(fake.pluginCreateArgsForCall)
}

func (fake *fakeDockerClient) PluginCreateArgsForCall(i int) (contextPkg.Context, io.Reader, types.PluginCreateOptions) {
	fake.pluginCreateMutex.RLock()
	defer fake.pluginCreateMutex.RUnlock()
	return fake.pluginCreateArgsForCall[i].ctx, fake.pluginCreateArgsForCall[i].createContext, fake.pluginCreateArgsForCall[i].options
}

func (fake *fakeDockerClient) PluginCreateReturns(result1 error) {
	fake.PluginCreateStub = nil
	fake.pluginCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginCreateReturnsOnCall(i int, result1 error) {
	fake.PluginCreateStub = nil
	if fake.pluginCreateReturnsOnCall == nil {
		fake.pluginCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pluginCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ServiceCreate(ctx contextPkg.Context, service swarmPkg.ServiceSpec, options types.ServiceCreateOptions) (types.ServiceCreateResponse, error) {
	fake.serviceCreateMutex.Lock()
	ret, specificReturn := fake.serviceCreateReturnsOnCall[len(fake.serviceCreateArgsForCall)]
	fake.serviceCreateArgsForCall = append(fake.serviceCreateArgsForCall, struct {
		ctx     contextPkg.Context
		service swarmPkg.ServiceSpec
		options types.ServiceCreateOptions
	}{ctx, service, options})
	fake.recordInvocation("ServiceCreate", []interface{}{ctx, service, options})
	fake.serviceCreateMutex.Unlock()
	if fake.ServiceCreateStub != nil {
		return fake.ServiceCreateStub(ctx, service, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.serviceCreateReturns.result1, fake.serviceCreateReturns.result2
}

func (fake *fakeDockerClient) ServiceCreateCallCount() int {
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	return len(fake.serviceCreateArgsForCall)
}

func (fake *fakeDockerClient) ServiceCreateArgsForCall(i int) (contextPkg.Context, swarmPkg.ServiceSpec, types.ServiceCreateOptions) {
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	return fake.serviceCreateArgsForCall[i].ctx, fake.serviceCreateArgsForCall[i].service, fake.serviceCreateArgsForCall[i].options
}

func (fake *fakeDockerClient) ServiceCreateReturns(result1 types.ServiceCreateResponse, result2 error) {
	fake.ServiceCreateStub = nil
	fake.serviceCreateReturns = struct {
		result1 types.ServiceCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceCreateReturnsOnCall(i int, result1 types.ServiceCreateResponse, result2 error) {
	fake.ServiceCreateStub = nil
	if fake.serviceCreateReturnsOnCall == nil {
		fake.serviceCreateReturnsOnCall = make(map[int]struct {
			result1 types.ServiceCreateResponse
			result2 error
		})
	}
	fake.serviceCreateReturnsOnCall[i] = struct {
		result1 types.ServiceCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceInspectWithRaw(ctx contextPkg.Context, serviceID string, options types.ServiceInspectOptions) (swarmPkg.Service, []byte, error) {
	fake.serviceInspectWithRawMutex.Lock()
	ret, specificReturn := fake.serviceInspectWithRawReturnsOnCall[len(fake.serviceInspectWithRawArgsForCall)]
	fake.serviceInspectWithRawArgsForCall = append(fake.serviceInspectWithRawArgsForCall, struct {
		ctx       contextPkg.Context
		serviceID string
		options   types.ServiceInspectOptions
	}{ctx, serviceID, options})
	fake.recordInvocation("ServiceInspectWithRaw", []interface{}{ctx, serviceID, options})
	fake.serviceInspectWithRawMutex.Unlock()
	if fake.ServiceInspectWithRawStub != nil {
		return fake.ServiceInspectWithRawStub(ctx, serviceID, options)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.serviceInspectWithRawReturns.result1, fake.serviceInspectWithRawReturns.result2, fake.serviceInspectWithRawReturns.result3
}

func (fake *fakeDockerClient) ServiceInspectWithRawCallCount() int {
	fake.serviceInspectWithRawMutex.RLock()
	defer fake.serviceInspectWithRawMutex.RUnlock()
	return len(fake.serviceInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) ServiceInspectWithRawArgsForCall(i int) (contextPkg.Context, string, types.ServiceInspectOptions) {
	fake.serviceInspectWithRawMutex.RLock()
	defer fake.serviceInspectWithRawMutex.RUnlock()
	return fake.serviceInspectWithRawArgsForCall[i].ctx, fake.serviceInspectWithRawArgsForCall[i].serviceID, fake.serviceInspectWithRawArgsForCall[i].options
}

func (fake *fakeDockerClient) ServiceInspectWithRawReturns(result1 swarmPkg.Service, result2 []byte, result3 error) {
	fake.ServiceInspectWithRawStub = nil
	fake.serviceInspectWithRawReturns = struct {
		result1 swarmPkg.Service
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ServiceInspectWithRawReturnsOnCall(i int, result1 swarmPkg.Service, result2 []byte, result3 error) {
	fake.ServiceInspectWithRawStub = nil
	if fake.serviceInspectWithRawReturnsOnCall == nil {
		fake.serviceInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 swarmPkg.Service
			result2 []byte
			result3 error
		})
	}
	fake.serviceInspectWithRawReturnsOnCall[i] = struct {
		result1 swarmPkg.Service
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ServiceList(ctx contextPkg.Context, options types.ServiceListOptions) ([]swarmPkg.Service, error) {
	fake.serviceListMutex.Lock()
	ret, specificReturn := fake.serviceListReturnsOnCall[len(fake.serviceListArgsForCall)]
	fake.serviceListArgsForCall = append(fake.serviceListArgsForCall, struct {
		ctx     contextPkg.Context
		options types.ServiceListOptions
	}{ctx, options})
	fake.recordInvocation("ServiceList", []interface{}{ctx, options})
	fake.serviceListMutex.Unlock()
	if fake.ServiceListStub != nil {
		return fake.ServiceListStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.serviceListReturns.result1, fake.serviceListReturns.result2
}

func (fake *fakeDockerClient) ServiceListCallCount() int {
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	return len(fake.serviceListArgsForCall)
}

func (fake *fakeDockerClient) ServiceListArgsForCall(i int) (contextPkg.Context, types.ServiceListOptions) {
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	return fake.serviceListArgsForCall[i].ctx, fake.serviceListArgsForCall[i].options
}

func (fake *fakeDockerClient) ServiceListReturns(result1 []swarmPkg.Service, result2 error) {
	fake.ServiceListStub = nil
	fake.serviceListReturns = struct {
		result1 []swarmPkg.Service
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceListReturnsOnCall(i int, result1 []swarmPkg.Service, result2 error) {
	fake.ServiceListStub = nil
	if fake.serviceListReturnsOnCall == nil {
		fake.serviceListReturnsOnCall = make(map[int]struct {
			result1 []swarmPkg.Service
			result2 error
		})
	}
	fake.serviceListReturnsOnCall[i] = struct {
		result1 []swarmPkg.Service
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceRemove(ctx contextPkg.Context, serviceID string) error {
	fake.serviceRemoveMutex.Lock()
	ret, specificReturn := fake.serviceRemoveReturnsOnCall[len(fake.serviceRemoveArgsForCall)]
	fake.serviceRemoveArgsForCall = append(fake.serviceRemoveArgsForCall, struct {
		ctx       contextPkg.Context
		serviceID string
	}{ctx, serviceID})
	fake.recordInvocation("ServiceRemove", []interface{}{ctx, serviceID})
	fake.serviceRemoveMutex.Unlock()
	if fake.ServiceRemoveStub != nil {
		return fake.ServiceRemoveStub(ctx, serviceID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.serviceRemoveReturns.result1
}

func (fake *fakeDockerClient) ServiceRemoveCallCount() int {
	fake.serviceRemoveMutex.RLock()
	defer fake.serviceRemoveMutex.RUnlock()
	return len(fake.serviceRemoveArgsForCall)
}

func (fake *fakeDockerClient) ServiceRemoveArgsForCall(i int) (contextPkg.Context, string) {
	fake.serviceRemoveMutex.RLock()
	defer fake.serviceRemoveMutex.RUnlock()
	return fake.serviceRemoveArgsForCall[i].ctx, fake.serviceRemoveArgsForCall[i].serviceID
}

func (fake *fakeDockerClient) ServiceRemoveReturns(result1 error) {
	fake.ServiceRemoveStub = nil
	fake.serviceRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ServiceRemoveReturnsOnCall(i int, result1 error) {
	fake.ServiceRemoveStub = nil
	if fake.serviceRemoveReturnsOnCall == nil {
		fake.serviceRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ServiceUpdate(ctx contextPkg.Context, serviceID string, version swarmPkg.Version, service swarmPkg.ServiceSpec, options types.ServiceUpdateOptions) (types.ServiceUpdateResponse, error) {
	fake.serviceUpdateMutex.Lock()
	ret, specificReturn := fake.serviceUpdateReturnsOnCall[len(fake.serviceUpdateArgsForCall)]
	fake.serviceUpdateArgsForCall = append(fake.serviceUpdateArgsForCall, struct {
		ctx       contextPkg.Context
		serviceID string
		version   swarmPkg.Version
		service   swarmPkg.ServiceSpec
		options   types.ServiceUpdateOptions
	}{ctx, serviceID, version, service, options})
	fake.recordInvocation("ServiceUpdate", []interface{}{ctx, serviceID, version, service, options})
	fake.serviceUpdateMutex.Unlock()
	if fake.ServiceUpdateStub != nil {
		return fake.ServiceUpdateStub(ctx, serviceID, version, service, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.serviceUpdateReturns.result1, fake.serviceUpdateReturns.result2
}

func (fake *fakeDockerClient) ServiceUpdateCallCount() int {
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	return len(fake.serviceUpdateArgsForCall)
}

func (fake *fakeDockerClient) ServiceUpdateArgsForCall(i int) (contextPkg.Context, string, swarmPkg.Version, swarmPkg.ServiceSpec, types.ServiceUpdateOptions) {
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	return fake.serviceUpdateArgsForCall[i].ctx, fake.serviceUpdateArgsForCall[i].serviceID, fake.serviceUpdateArgsForCall[i].version, fake.serviceUpdateArgsForCall[i].service, fake.serviceUpdateArgsForCall[i].options
}

func (fake *fakeDockerClient) ServiceUpdateReturns(result1 types.ServiceUpdateResponse, result2 error) {
	fake.ServiceUpdateStub = nil
	fake.serviceUpdateReturns = struct {
		result1 types.ServiceUpdateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceUpdateReturnsOnCall(i int, result1 types.ServiceUpdateResponse, result2 error) {
	fake.ServiceUpdateStub = nil
	if fake.serviceUpdateReturnsOnCall == nil {
		fake.serviceUpdateReturnsOnCall = make(map[int]struct {
			result1 types.ServiceUpdateResponse
			result2 error
		})
	}
	fake.serviceUpdateReturnsOnCall[i] = struct {
		result1 types.ServiceUpdateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceLogs(ctx contextPkg.Context, serviceID string, options types.ContainerLogsOptions) (io.ReadCloser, error) {
	fake.serviceLogsMutex.Lock()
	ret, specificReturn := fake.serviceLogsReturnsOnCall[len(fake.serviceLogsArgsForCall)]
	fake.serviceLogsArgsForCall = append(fake.serviceLogsArgsForCall, struct {
		ctx       contextPkg.Context
		serviceID string
		options   types.ContainerLogsOptions
	}{ctx, serviceID, options})
	fake.recordInvocation("ServiceLogs", []interface{}{ctx, serviceID, options})
	fake.serviceLogsMutex.Unlock()
	if fake.ServiceLogsStub != nil {
		return fake.ServiceLogsStub(ctx, serviceID, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.serviceLogsReturns.result1, fake.serviceLogsReturns.result2
}

func (fake *fakeDockerClient) ServiceLogsCallCount() int {
	fake.serviceLogsMutex.RLock()
	defer fake.serviceLogsMutex.RUnlock()
	return len(fake.serviceLogsArgsForCall)
}

func (fake *fakeDockerClient) ServiceLogsArgsForCall(i int) (contextPkg.Context, string, types.ContainerLogsOptions) {
	fake.serviceLogsMutex.RLock()
	defer fake.serviceLogsMutex.RUnlock()
	return fake.serviceLogsArgsForCall[i].ctx, fake.serviceLogsArgsForCall[i].serviceID, fake.serviceLogsArgsForCall[i].options
}

func (fake *fakeDockerClient) ServiceLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.ServiceLogsStub = nil
	fake.serviceLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceLogsReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ServiceLogsStub = nil
	if fake.serviceLogsReturnsOnCall == nil {
		fake.serviceLogsReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.serviceLogsReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) TaskLogs(ctx contextPkg.Context, taskID string, options types.ContainerLogsOptions) (io.ReadCloser, error) {
	fake.taskLogsMutex.Lock()
	ret, specificReturn := fake.taskLogsReturnsOnCall[len(fake.taskLogsArgsForCall)]
	fake.taskLogsArgsForCall = append(fake.taskLogsArgsForCall, struct {
		ctx     contextPkg.Context
		taskID  string
		options types.ContainerLogsOptions
	}{ctx, taskID, options})
	fake.recordInvocation("TaskLogs", []interface{}{ctx, taskID, options})
	fake.taskLogsMutex.Unlock()
	if fake.TaskLogsStub != nil {
		return fake.TaskLogsStub(ctx, taskID, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.taskLogsReturns.result1, fake.taskLogsReturns.result2
}

func (fake *fakeDockerClient) TaskLogsCallCount() int {
	fake.taskLogsMutex.RLock()
	defer fake.taskLogsMutex.RUnlock()
	return len(fake.taskLogsArgsForCall)
}

func (fake *fakeDockerClient) TaskLogsArgsForCall(i int) (contextPkg.Context, string, types.ContainerLogsOptions) {
	fake.taskLogsMutex.RLock()
	defer fake.taskLogsMutex.RUnlock()
	return fake.taskLogsArgsForCall[i].ctx, fake.taskLogsArgsForCall[i].taskID, fake.taskLogsArgsForCall[i].options
}

func (fake *fakeDockerClient) TaskLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.TaskLogsStub = nil
	fake.taskLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) TaskLogsReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.TaskLogsStub = nil
	if fake.taskLogsReturnsOnCall == nil {
		fake.taskLogsReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.taskLogsReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) TaskInspectWithRaw(ctx contextPkg.Context, taskID string) (swarmPkg.Task, []byte, error) {
	fake.taskInspectWithRawMutex.Lock()
	ret, specificReturn := fake.taskInspectWithRawReturnsOnCall[len(fake.taskInspectWithRawArgsForCall)]
	fake.taskInspectWithRawArgsForCall = append(fake.taskInspectWithRawArgsForCall, struct {
		ctx    contextPkg.Context
		taskID string
	}{ctx, taskID})
	fake.recordInvocation("TaskInspectWithRaw", []interface{}{ctx, taskID})
	fake.taskInspectWithRawMutex.Unlock()
	if fake.TaskInspectWithRawStub != nil {
		return fake.TaskInspectWithRawStub(ctx, taskID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.taskInspectWithRawReturns.result1, fake.taskInspectWithRawReturns.result2, fake.taskInspectWithRawReturns.result3
}

func (fake *fakeDockerClient) TaskInspectWithRawCallCount() int {
	fake.taskInspectWithRawMutex.RLock()
	defer fake.taskInspectWithRawMutex.RUnlock()
	return len(fake.taskInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) TaskInspectWithRawArgsForCall(i int) (contextPkg.Context, string) {
	fake.taskInspectWithRawMutex.RLock()
	defer fake.taskInspectWithRawMutex.RUnlock()
	return fake.taskInspectWithRawArgsForCall[i].ctx, fake.taskInspectWithRawArgsForCall[i].taskID
}

func (fake *fakeDockerClient) TaskInspectWithRawReturns(result1 swarmPkg.Task, result2 []byte, result3 error) {
	fake.TaskInspectWithRawStub = nil
	fake.taskInspectWithRawReturns = struct {
		result1 swarmPkg.Task
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) TaskInspectWithRawReturnsOnCall(i int, result1 swarmPkg.Task, result2 []byte, result3 error) {
	fake.TaskInspectWithRawStub = nil
	if fake.taskInspectWithRawReturnsOnCall == nil {
		fake.taskInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 swarmPkg.Task
			result2 []byte
			result3 error
		})
	}
	fake.taskInspectWithRawReturnsOnCall[i] = struct {
		result1 swarmPkg.Task
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) TaskList(ctx contextPkg.Context, options types.TaskListOptions) ([]swarmPkg.Task, error) {
	fake.taskListMutex.Lock()
	ret, specificReturn := fake.taskListReturnsOnCall[len(fake.taskListArgsForCall)]
	fake.taskListArgsForCall = append(fake.taskListArgsForCall, struct {
		ctx     contextPkg.Context
		options types.TaskListOptions
	}{ctx, options})
	fake.recordInvocation("TaskList", []interface{}{ctx, options})
	fake.taskListMutex.Unlock()
	if fake.TaskListStub != nil {
		return fake.TaskListStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.taskListReturns.result1, fake.taskListReturns.result2
}

func (fake *fakeDockerClient) TaskListCallCount() int {
	fake.taskListMutex.RLock()
	defer fake.taskListMutex.RUnlock()
	return len(fake.taskListArgsForCall)
}

func (fake *fakeDockerClient) TaskListArgsForCall(i int) (contextPkg.Context, types.TaskListOptions) {
	fake.taskListMutex.RLock()
	defer fake.taskListMutex.RUnlock()
	return fake.taskListArgsForCall[i].ctx, fake.taskListArgsForCall[i].options
}

func (fake *fakeDockerClient) TaskListReturns(result1 []swarmPkg.Task, result2 error) {
	fake.TaskListStub = nil
	fake.taskListReturns = struct {
		result1 []swarmPkg.Task
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) TaskListReturnsOnCall(i int, result1 []swarmPkg.Task, result2 error) {
	fake.TaskListStub = nil
	if fake.taskListReturnsOnCall == nil {
		fake.taskListReturnsOnCall = make(map[int]struct {
			result1 []swarmPkg.Task
			result2 error
		})
	}
	fake.taskListReturnsOnCall[i] = struct {
		result1 []swarmPkg.Task
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmInit(ctx contextPkg.Context, req swarmPkg.InitRequest) (string, error) {
	fake.swarmInitMutex.Lock()
	ret, specificReturn := fake.swarmInitReturnsOnCall[len(fake.swarmInitArgsForCall)]
	fake.swarmInitArgsForCall = append(fake.swarmInitArgsForCall, struct {
		ctx contextPkg.Context
		req swarmPkg.InitRequest
	}{ctx, req})
	fake.recordInvocation("SwarmInit", []interface{}{ctx, req})
	fake.swarmInitMutex.Unlock()
	if fake.SwarmInitStub != nil {
		return fake.SwarmInitStub(ctx, req)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.swarmInitReturns.result1, fake.swarmInitReturns.result2
}

func (fake *fakeDockerClient) SwarmInitCallCount() int {
	fake.swarmInitMutex.RLock()
	defer fake.swarmInitMutex.RUnlock()
	return len(fake.swarmInitArgsForCall)
}

func (fake *fakeDockerClient) SwarmInitArgsForCall(i int) (contextPkg.Context, swarmPkg.InitRequest) {
	fake.swarmInitMutex.RLock()
	defer fake.swarmInitMutex.RUnlock()
	return fake.swarmInitArgsForCall[i].ctx, fake.swarmInitArgsForCall[i].req
}

func (fake *fakeDockerClient) SwarmInitReturns(result1 string, result2 error) {
	fake.SwarmInitStub = nil
	fake.swarmInitReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmInitReturnsOnCall(i int, result1 string, result2 error) {
	fake.SwarmInitStub = nil
	if fake.swarmInitReturnsOnCall == nil {
		fake.swarmInitReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.swarmInitReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmJoin(ctx contextPkg.Context, req swarmPkg.JoinRequest) error {
	fake.swarmJoinMutex.Lock()
	ret, specificReturn := fake.swarmJoinReturnsOnCall[len(fake.swarmJoinArgsForCall)]
	fake.swarmJoinArgsForCall = append(fake.swarmJoinArgsForCall, struct {
		ctx contextPkg.Context
		req swarmPkg.JoinRequest
	}{ctx, req})
	fake.recordInvocation("SwarmJoin", []interface{}{ctx, req})
	fake.swarmJoinMutex.Unlock()
	if fake.SwarmJoinStub != nil {
		return fake.SwarmJoinStub(ctx, req)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.swarmJoinReturns.result1
}

func (fake *fakeDockerClient) SwarmJoinCallCount() int {
	fake.swarmJoinMutex.RLock()
	defer fake.swarmJoinMutex.RUnlock()
	return len(fake.swarmJoinArgsForCall)
}

func (fake *fakeDockerClient) SwarmJoinArgsForCall(i int) (contextPkg.Context, swarmPkg.JoinRequest) {
	fake.swarmJoinMutex.RLock()
	defer fake.swarmJoinMutex.RUnlock()
	return fake.swarmJoinArgsForCall[i].ctx, fake.swarmJoinArgsForCall[i].req
}

func (fake *fakeDockerClient) SwarmJoinReturns(result1 error) {
	fake.SwarmJoinStub = nil
	fake.swarmJoinReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmJoinReturnsOnCall(i int, result1 error) {
	fake.SwarmJoinStub = nil
	if fake.swarmJoinReturnsOnCall == nil {
		fake.swarmJoinReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.swarmJoinReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmGetUnlockKey(ctx contextPkg.Context) (types.SwarmUnlockKeyResponse, error) {
	fake.swarmGetUnlockKeyMutex.Lock()
	ret, specificReturn := fake.swarmGetUnlockKeyReturnsOnCall[len(fake.swarmGetUnlockKeyArgsForCall)]
	fake.swarmGetUnlockKeyArgsForCall = append(fake.swarmGetUnlockKeyArgsForCall, struct {
		ctx contextPkg.Context
	}{ctx})
	fake.recordInvocation("SwarmGetUnlockKey", []interface{}{ctx})
	fake.swarmGetUnlockKeyMutex.Unlock()
	if fake.SwarmGetUnlockKeyStub != nil {
		return fake.SwarmGetUnlockKeyStub(ctx)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.swarmGetUnlockKeyReturns.result1, fake.swarmGetUnlockKeyReturns.result2
}

func (fake *fakeDockerClient) SwarmGetUnlockKeyCallCount() int {
	fake.swarmGetUnlockKeyMutex.RLock()
	defer fake.swarmGetUnlockKeyMutex.RUnlock()
	return len(fake.swarmGetUnlockKeyArgsForCall)
}

func (fake *fakeDockerClient) SwarmGetUnlockKeyArgsForCall(i int) contextPkg.Context {
	fake.swarmGetUnlockKeyMutex.RLock()
	defer fake.swarmGetUnlockKeyMutex.RUnlock()
	return fake.swarmGetUnlockKeyArgsForCall[i].ctx
}

func (fake *fakeDockerClient) SwarmGetUnlockKeyReturns(result1 types.SwarmUnlockKeyResponse, result2 error) {
	fake.SwarmGetUnlockKeyStub = nil
	fake.swarmGetUnlockKeyReturns = struct {
		result1 types.SwarmUnlockKeyResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmGetUnlockKeyReturnsOnCall(i int, result1 types.SwarmUnlockKeyResponse, result2 error) {
	fake.SwarmGetUnlockKeyStub = nil
	if fake.swarmGetUnlockKeyReturnsOnCall == nil {
		fake.swarmGetUnlockKeyReturnsOnCall = make(map[int]struct {
			result1 types.SwarmUnlockKeyResponse
			result2 error
		})
	}
	fake.swarmGetUnlockKeyReturnsOnCall[i] = struct {
		result1 types.SwarmUnlockKeyResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmUnlock(ctx contextPkg.Context, req swarmPkg.UnlockRequest) error {
	fake.swarmUnlockMutex.Lock()
	ret, specificReturn := fake.swarmUnlockReturnsOnCall[len(fake.swarmUnlockArgsForCall)]
	fake.swarmUnlockArgsForCall = append(fake.swarmUnlockArgsForCall, struct {
		ctx contextPkg.Context
		req swarmPkg.UnlockRequest
	}{ctx, req})
	fake.recordInvocation("SwarmUnlock", []interface{}{ctx, req})
	fake.swarmUnlockMutex.Unlock()
	if fake.SwarmUnlockStub != nil {
		return fake.SwarmUnlockStub(ctx, req)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.swarmUnlockReturns.result1
}

func (fake *fakeDockerClient) SwarmUnlockCallCount() int {
	fake.swarmUnlockMutex.RLock()
	defer fake.swarmUnlockMutex.RUnlock()
	return len(fake.swarmUnlockArgsForCall)
}

func (fake *fakeDockerClient) SwarmUnlockArgsForCall(i int) (contextPkg.Context, swarmPkg.UnlockRequest) {
	fake.swarmUnlockMutex.RLock()
	defer fake.swarmUnlockMutex.RUnlock()
	return fake.swarmUnlockArgsForCall[i].ctx, fake.swarmUnlockArgsForCall[i].req
}

func (fake *fakeDockerClient) SwarmUnlockReturns(result1 error) {
	fake.SwarmUnlockStub = nil
	fake.swarmUnlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmUnlockReturnsOnCall(i int, result1 error) {
	fake.SwarmUnlockStub = nil
	if fake.swarmUnlockReturnsOnCall == nil {
		fake.swarmUnlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.swarmUnlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmLeave(ctx contextPkg.Context, force bool) error {
	fake.swarmLeaveMutex.Lock()
	ret, specificReturn := fake.swarmLeaveReturnsOnCall[len(fake.swarmLeaveArgsForCall)]
	fake.swarmLeaveArgsForCall = append(fake.swarmLeaveArgsForCall, struct {
		ctx   contextPkg.Context
		force bool
	}{ctx, force})
	fake.recordInvocation("SwarmLeave", []interface{}{ctx, force})
	fake.swarmLeaveMutex.Unlock()
	if fake.SwarmLeaveStub != nil {
		return fake.SwarmLeaveStub(ctx, force)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.swarmLeaveReturns.result1
}

func (fake *fakeDockerClient) SwarmLeaveCallCount() int {
	fake.swarmLeaveMutex.RLock()
	defer fake.swarmLeaveMutex.RUnlock()
	return len(fake.swarmLeaveArgsForCall)
}

func (fake *fakeDockerClient) SwarmLeaveArgsForCall(i int) (contextPkg.Context, bool) {
	fake.swarmLeaveMutex.RLock()
	defer fake.swarmLeaveMutex.RUnlock()
	return fake.swarmLeaveArgsForCall[i].ctx, fake.swarmLeaveArgsForCall[i].force
}

func (fake *fakeDockerClient) SwarmLeaveReturns(result1 error) {
	fake.SwarmLeaveStub = nil
	fake.swarmLeaveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmLeaveReturnsOnCall(i int, result1 error) {
	fake.SwarmLeaveStub = nil
	if fake.swarmLeaveReturnsOnCall == nil {
		fake.swarmLeaveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.swarmLeaveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmInspect(ctx contextPkg.Context) (swarmPkg.Swarm, error) {
	fake.swarmInspectMutex.Lock()
	ret, specificReturn := fake.swarmInspectReturnsOnCall[len(fake.swarmInspectArgsForCall)]
	fake.swarmInspectArgsForCall = append(fake.swarmInspectArgsForCall, struct {
		ctx contextPkg.Context
	}{ctx})
	fake.recordInvocation("SwarmInspect", []interface{}{ctx})
	fake.swarmInspectMutex.Unlock()
	if fake.SwarmInspectStub != nil {
		return fake.SwarmInspectStub(ctx)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.swarmInspectReturns.result1, fake.swarmInspectReturns.result2
}

func (fake *fakeDockerClient) SwarmInspectCallCount() int {
	fake.swarmInspectMutex.RLock()
	defer fake.swarmInspectMutex.RUnlock()
	return len(fake.swarmInspectArgsForCall)
}

func (fake *fakeDockerClient) SwarmInspectArgsForCall(i int) contextPkg.Context {
	fake.swarmInspectMutex.RLock()
	defer fake.swarmInspectMutex.RUnlock()
	return fake.swarmInspectArgsForCall[i].ctx
}

func (fake *fakeDockerClient) SwarmInspectReturns(result1 swarmPkg.Swarm, result2 error) {
	fake.SwarmInspectStub = nil
	fake.swarmInspectReturns = struct {
		result1 swarmPkg.Swarm
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmInspectReturnsOnCall(i int, result1 swarmPkg.Swarm, result2 error) {
	fake.SwarmInspectStub = nil
	if fake.swarmInspectReturnsOnCall == nil {
		fake.swarmInspectReturnsOnCall = make(map[int]struct {
			result1 swarmPkg.Swarm
			result2 error
		})
	}
	fake.swarmInspectReturnsOnCall[i] = struct {
		result1 swarmPkg.Swarm
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmUpdate(ctx contextPkg.Context, version swarmPkg.Version, swarm swarmPkg.Spec, flags swarmPkg.UpdateFlags) error {
	fake.swarmUpdateMutex.Lock()
	ret, specificReturn := fake.swarmUpdateReturnsOnCall[len(fake.swarmUpdateArgsForCall)]
	fake.swarmUpdateArgsForCall = append(fake.swarmUpdateArgsForCall, struct {
		ctx     contextPkg.Context
		version swarmPkg.Version
		swarm   swarmPkg.Spec
		flags   swarmPkg.UpdateFlags
	}{ctx, version, swarm, flags})
	fake.recordInvocation("SwarmUpdate", []interface{}{ctx, version, swarm, flags})
	fake.swarmUpdateMutex.Unlock()
	if fake.SwarmUpdateStub != nil {
		return fake.SwarmUpdateStub(ctx, version, swarm, flags)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.swarmUpdateReturns.result1
}

func (fake *fakeDockerClient) SwarmUpdateCallCount() int {
	fake.swarmUpdateMutex.RLock()
	defer fake.swarmUpdateMutex.RUnlock()
	return len(fake.swarmUpdateArgsForCall)
}

func (fake *fakeDockerClient) SwarmUpdateArgsForCall(i int) (contextPkg.Context, swarmPkg.Version, swarmPkg.Spec, swarmPkg.UpdateFlags) {
	fake.swarmUpdateMutex.RLock()
	defer fake.swarmUpdateMutex.RUnlock()
	return fake.swarmUpdateArgsForCall[i].ctx, fake.swarmUpdateArgsForCall[i].version, fake.swarmUpdateArgsForCall[i].swarm, fake.swarmUpdateArgsForCall[i].flags
}

func (fake *fakeDockerClient) SwarmUpdateReturns(result1 error) {
	fake.SwarmUpdateStub = nil
	fake.swarmUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmUpdateReturnsOnCall(i int, result1 error) {
	fake.SwarmUpdateStub = nil
	if fake.swarmUpdateReturnsOnCall == nil {
		fake.swarmUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.swarmUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SecretList(ctx contextPkg.Context, options types.SecretListOptions) ([]swarmPkg.Secret, error) {
	fake.secretListMutex.Lock()
	ret, specificReturn := fake.secretListReturnsOnCall[len(fake.secretListArgsForCall)]
	fake.secretListArgsForCall = append(fake.secretListArgsForCall, struct {
		ctx     contextPkg.Context
		options types.SecretListOptions
	}{ctx, options})
	fake.recordInvocation("SecretList", []interface{}{ctx, options})
	fake.secretListMutex.Unlock()
	if fake.SecretListStub != nil {
		return fake.SecretListStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.secretListReturns.result1, fake.secretListReturns.result2
}

func (fake *fakeDockerClient) SecretListCallCount() int {
	fake.secretListMutex.RLock()
	defer fake.secretListMutex.RUnlock()
	return len(fake.secretListArgsForCall)
}

func (fake *fakeDockerClient) SecretListArgsForCall(i int) (contextPkg.Context, types.SecretListOptions) {
	fake.secretListMutex.RLock()
	defer fake.secretListMutex.RUnlock()
	return fake.secretListArgsForCall[i].ctx, fake.secretListArgsForCall[i].options
}

func (fake *fakeDockerClient) SecretListReturns(result1 []swarmPkg.Secret, result2 error) {
	fake.SecretListStub = nil
	fake.secretListReturns = struct {
		result1 []swarmPkg.Secret
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SecretListReturnsOnCall(i int, result1 []swarmPkg.Secret, result2 error) {
	fake.SecretListStub = nil
	if fake.secretListReturnsOnCall == nil {
		fake.secretListReturnsOnCall = make(map[int]struct {
			result1 []swarmPkg.Secret
			result2 error
		})
	}
	fake.secretListReturnsOnCall[i] = struct {
		result1 []swarmPkg.Secret
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SecretCreate(ctx contextPkg.Context, secret swarmPkg.SecretSpec) (types.SecretCreateResponse, error) {
	fake.secretCreateMutex.Lock()
	ret, specificReturn := fake.secretCreateReturnsOnCall[len(fake.secretCreateArgsForCall)]
	fake.secretCreateArgsForCall = append(fake.secretCreateArgsForCall, struct {
		ctx    contextPkg.Context
		secret swarmPkg.SecretSpec
	}{ctx, secret})
	fake.recordInvocation("SecretCreate", []interface{}{ctx, secret})
	fake.secretCreateMutex.Unlock()
	if fake.SecretCreateStub != nil {
		return fake.SecretCreateStub(ctx, secret)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.secretCreateReturns.result1, fake.secretCreateReturns.result2
}

func (fake *fakeDockerClient) SecretCreateCallCount() int {
	fake.secretCreateMutex.RLock()
	defer fake.secretCreateMutex.RUnlock()
	return len(fake.secretCreateArgsForCall)
}

func (fake *fakeDockerClient) SecretCreateArgsForCall(i int) (contextPkg.Context, swarmPkg.SecretSpec) {
	fake.secretCreateMutex.RLock()
	defer fake.secretCreateMutex.RUnlock()
	return fake.secretCreateArgsForCall[i].ctx, fake.secretCreateArgsForCall[i].secret
}

func (fake *fakeDockerClient) SecretCreateReturns(result1 types.SecretCreateResponse, result2 error) {
	fake.SecretCreateStub = nil
	fake.secretCreateReturns = struct {
		result1 types.SecretCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SecretCreateReturnsOnCall(i int, result1 types.SecretCreateResponse, result2 error) {
	fake.SecretCreateStub = nil
	if fake.secretCreateReturnsOnCall == nil {
		fake.secretCreateReturnsOnCall = make(map[int]struct {
			result1 types.SecretCreateResponse
			result2 error
		})
	}
	fake.secretCreateReturnsOnCall[i] = struct {
		result1 types.SecretCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SecretRemove(ctx contextPkg.Context, id string) error {
	fake.secretRemoveMutex.Lock()
	ret, specificReturn := fake.secretRemoveReturnsOnCall[len(fake.secretRemoveArgsForCall)]
	fake.secretRemoveArgsForCall = append(fake.secretRemoveArgsForCall, struct {
		ctx contextPkg.Context
		id  string
	}{ctx, id})
	fake.recordInvocation("SecretRemove", []interface{}{ctx, id})
	fake.secretRemoveMutex.Unlock()
	if fake.SecretRemoveStub != nil {
		return fake.SecretRemoveStub(ctx, id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.secretRemoveReturns.result1
}

func (fake *fakeDockerClient) SecretRemoveCallCount() int {
	fake.secretRemoveMutex.RLock()
	defer fake.secretRemoveMutex.RUnlock()
	return len(fake.secretRemoveArgsForCall)
}

func (fake *fakeDockerClient) SecretRemoveArgsForCall(i int) (contextPkg.Context, string) {
	fake.secretRemoveMutex.RLock()
	defer fake.secretRemoveMutex.RUnlock()
	return fake.secretRemoveArgsForCall[i].ctx, fake.secretRemoveArgsForCall[i].id
}

func (fake *fakeDockerClient) SecretRemoveReturns(result1 error) {
	fake.SecretRemoveStub = nil
	fake.secretRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SecretRemoveReturnsOnCall(i int, result1 error) {
	fake.SecretRemoveStub = nil
	if fake.secretRemoveReturnsOnCall == nil {
		fake.secretRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.secretRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SecretInspectWithRaw(ctx contextPkg.Context, name string) (swarmPkg.Secret, []byte, error) {
	fake.secretInspectWithRawMutex.Lock()
	ret, specificReturn := fake.secretInspectWithRawReturnsOnCall[len(fake.secretInspectWithRawArgsForCall)]
	fake.secretInspectWithRawArgsForCall = append(fake.secretInspectWithRawArgsForCall, struct {
		ctx  contextPkg.Context
		name string
	}{ctx, name})
	fake.recordInvocation("SecretInspectWithRaw", []interface{}{ctx, name})
	fake.secretInspectWithRawMutex.Unlock()
	if fake.SecretInspectWithRawStub != nil {
		return fake.SecretInspectWithRawStub(ctx, name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.secretInspectWithRawReturns.result1, fake.secretInspectWithRawReturns.result2, fake.secretInspectWithRawReturns.result3
}

func (fake *fakeDockerClient) SecretInspectWithRawCallCount() int {
	fake.secretInspectWithRawMutex.RLock()
	defer fake.secretInspectWithRawMutex.RUnlock()
	return len(fake.secretInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) SecretInspectWithRawArgsForCall(i int) (contextPkg.Context, string) {
	fake.secretInspectWithRawMutex.RLock()
	defer fake.secretInspectWithRawMutex.RUnlock()
	return fake.secretInspectWithRawArgsForCall[i].ctx, fake.secretInspectWithRawArgsForCall[i].name
}

func (fake *fakeDockerClient) SecretInspectWithRawReturns(result1 swarmPkg.Secret, result2 []byte, result3 error) {
	fake.SecretInspectWithRawStub = nil
	fake.secretInspectWithRawReturns = struct {
		result1 swarmPkg.Secret
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) SecretInspectWithRawReturnsOnCall(i int, result1 swarmPkg.Secret, result2 []byte, result3 error) {
	fake.SecretInspectWithRawStub = nil
	if fake.secretInspectWithRawReturnsOnCall == nil {
		fake.secretInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 swarmPkg.Secret
			result2 []byte
			result3 error
		})
	}
	fake.secretInspectWithRawReturnsOnCall[i] = struct {
		result1 swarmPkg.Secret
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) SecretUpdate(ctx contextPkg.Context, id string, version swarmPkg.Version, secret swarmPkg.SecretSpec) error {
	fake.secretUpdateMutex.Lock()
	ret, specificReturn := fake.secretUpdateReturnsOnCall[len(fake.secretUpdateArgsForCall)]
	fake.secretUpdateArgsForCall = append(fake.secretUpdateArgsForCall, struct {
		ctx     contextPkg.Context
		id      string
		version swarmPkg.Version
		secret  swarmPkg.SecretSpec
	}{ctx, id, version, secret})
	fake.recordInvocation("SecretUpdate", []interface{}{ctx, id, version, secret})
	fake.secretUpdateMutex.Unlock()
	if fake.SecretUpdateStub != nil {
		return fake.SecretUpdateStub(ctx, id, version, secret)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.secretUpdateReturns.result1
}

func (fake *fakeDockerClient) SecretUpdateCallCount() int {
	fake.secretUpdateMutex.RLock()
	defer fake.secretUpdateMutex.RUnlock()
	return len(fake.secretUpdateArgsForCall)
}

func (fake *fakeDockerClient) SecretUpdateArgsForCall(i int) (contextPkg.Context, string, swarmPkg.Version, swarmPkg.SecretSpec) {
	fake.secretUpdateMutex.RLock()
	defer fake.secretUpdateMutex.RUnlock()
	return fake.secretUpdateArgsForCall[i].ctx, fake.secretUpdateArgsForCall[i].id, fake.secretUpdateArgsForCall[i].version, fake.secretUpdateArgsForCall[i].secret
}

func (fake *fakeDockerClient) SecretUpdateReturns(result1 error) {
	fake.SecretUpdateStub = nil
	fake.secretUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SecretUpdateReturnsOnCall(i int, result1 error) {
	fake.SecretUpdateStub = nil
	if fake.secretUpdateReturnsOnCall == nil {
		fake.secretUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.secretUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) Events(ctx contextPkg.Context, options types.EventsOptions) (<-chan events.Message, <-chan error) {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		ctx     contextPkg.Context
		options types.EventsOptions
	}{ctx, options})
	fake.recordInvocation("Events", []interface{}{ctx, options})
	fake.eventsMutex.Unlock()
	if fake.EventsStub != nil {
		return fake.EventsStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.eventsReturns.result1, fake.eventsReturns.result2
}

func (fake *fakeDockerClient) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *fakeDockerClient) EventsArgsForCall(i int) (contextPkg.Context, types.EventsOptions) {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return fake.eventsArgsForCall[i].ctx, fake.eventsArgsForCall[i].options
}

func (fake *fakeDockerClient) EventsReturns(result1 <-chan events.Message, result2 <-chan error) {
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 <-chan events.Message
		result2 <-chan error
	}{result1, result2}
}

func (fake *fakeDockerClient) EventsReturnsOnCall(i int, result1 <-chan events.Message, result2 <-chan error) {
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 <-chan events.Message
			result2 <-chan error
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 <-chan events.Message
		result2 <-chan error
	}{result1, result2}
}

func (fake *fakeDockerClient) Info(ctx contextPkg.Context) (types.Info, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
		ctx contextPkg.Context
	}{ctx})
	fake.recordInvocation("Info", []interface{}{ctx})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub(ctx)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.infoReturns.result1, fake.infoReturns.result2
}

func (fake *fakeDockerClient) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *fakeDockerClient) InfoArgsForCall(i int) contextPkg.Context {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return fake.infoArgsForCall[i].ctx
}

func (fake *fakeDockerClient) InfoReturns(result1 types.Info, result2 error) {
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 types.Info
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) InfoReturnsOnCall(i int, result1 types.Info, result2 error) {
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 types.Info
			result2 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 types.Info
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) RegistryLogin(ctx contextPkg.Context, auth types.AuthConfig) (registry.AuthenticateOKBody, error) {
	fake.registryLoginMutex.Lock()
	ret, specificReturn := fake.registryLoginReturnsOnCall[len(fake.registryLoginArgsForCall)]
	fake.registryLoginArgsForCall = append(fake.registryLoginArgsForCall, struct {
		ctx  contextPkg.Context
		auth types.AuthConfig
	}{ctx, auth})
	fake.recordInvocation("RegistryLogin", []interface{}{ctx, auth})
	fake.registryLoginMutex.Unlock()
	if fake.RegistryLoginStub != nil {
		return fake.RegistryLoginStub(ctx, auth)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.registryLoginReturns.result1, fake.registryLoginReturns.result2
}

func (fake *fakeDockerClient) RegistryLoginCallCount() int {
	fake.registryLoginMutex.RLock()
	defer fake.registryLoginMutex.RUnlock()
	return len(fake.registryLoginArgsForCall)
}

func (fake *fakeDockerClient) RegistryLoginArgsForCall(i int) (contextPkg.Context, types.AuthConfig) {
	fake.registryLoginMutex.RLock()
	defer fake.registryLoginMutex.RUnlock()
	return fake.registryLoginArgsForCall[i].ctx, fake.registryLoginArgsForCall[i].auth
}

func (fake *fakeDockerClient) RegistryLoginReturns(result1 registry.AuthenticateOKBody, result2 error) {
	fake.RegistryLoginStub = nil
	fake.registryLoginReturns = struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) RegistryLoginReturnsOnCall(i int, result1 registry.AuthenticateOKBody, result2 error) {
	fake.RegistryLoginStub = nil
	if fake.registryLoginReturnsOnCall == nil {
		fake.registryLoginReturnsOnCall = make(map[int]struct {
			result1 registry.AuthenticateOKBody
			result2 error
		})
	}
	fake.registryLoginReturnsOnCall[i] = struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) DiskUsage(ctx contextPkg.Context) (types.DiskUsage, error) {
	fake.diskUsageMutex.Lock()
	ret, specificReturn := fake.diskUsageReturnsOnCall[len(fake.diskUsageArgsForCall)]
	fake.diskUsageArgsForCall = append(fake.diskUsageArgsForCall, struct {
		ctx contextPkg.Context
	}{ctx})
	fake.recordInvocation("DiskUsage", []interface{}{ctx})
	fake.diskUsageMutex.Unlock()
	if fake.DiskUsageStub != nil {
		return fake.DiskUsageStub(ctx)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.diskUsageReturns.result1, fake.diskUsageReturns.result2
}

func (fake *fakeDockerClient) DiskUsageCallCount() int {
	fake.diskUsageMutex.RLock()
	defer fake.diskUsageMutex.RUnlock()
	return len(fake.diskUsageArgsForCall)
}

func (fake *fakeDockerClient) DiskUsageArgsForCall(i int) contextPkg.Context {
	fake.diskUsageMutex.RLock()
	defer fake.diskUsageMutex.RUnlock()
	return fake.diskUsageArgsForCall[i].ctx
}

func (fake *fakeDockerClient) DiskUsageReturns(result1 types.DiskUsage, result2 error) {
	fake.DiskUsageStub = nil
	fake.diskUsageReturns = struct {
		result1 types.DiskUsage
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) DiskUsageReturnsOnCall(i int, result1 types.DiskUsage, result2 error) {
	fake.DiskUsageStub = nil
	if fake.diskUsageReturnsOnCall == nil {
		fake.diskUsageReturnsOnCall = make(map[int]struct {
			result1 types.DiskUsage
			result2 error
		})
	}
	fake.diskUsageReturnsOnCall[i] = struct {
		result1 types.DiskUsage
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) Ping(ctx contextPkg.Context) (types.Ping, error) {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		ctx contextPkg.Context
	}{ctx})
	fake.recordInvocation("Ping", []interface{}{ctx})
	fake.pingMutex.Unlock()
	if fake.PingStub != nil {
		return fake.PingStub(ctx)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pingReturns.result1, fake.pingReturns.result2
}

func (fake *fakeDockerClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *fakeDockerClient) PingArgsForCall(i int) contextPkg.Context {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return fake.pingArgsForCall[i].ctx
}

func (fake *fakeDockerClient) PingReturns(result1 types.Ping, result2 error) {
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 types.Ping
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PingReturnsOnCall(i int, result1 types.Ping, result2 error) {
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 types.Ping
			result2 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 types.Ping
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeCreate(ctx contextPkg.Context, options volumetypes.VolumesCreateBody) (types.Volume, error) {
	fake.volumeCreateMutex.Lock()
	ret, specificReturn := fake.volumeCreateReturnsOnCall[len(fake.volumeCreateArgsForCall)]
	fake.volumeCreateArgsForCall = append(fake.volumeCreateArgsForCall, struct {
		ctx     contextPkg.Context
		options volumetypes.VolumesCreateBody
	}{ctx, options})
	fake.recordInvocation("VolumeCreate", []interface{}{ctx, options})
	fake.volumeCreateMutex.Unlock()
	if fake.VolumeCreateStub != nil {
		return fake.VolumeCreateStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.volumeCreateReturns.result1, fake.volumeCreateReturns.result2
}

func (fake *fakeDockerClient) VolumeCreateCallCount() int {
	fake.volumeCreateMutex.RLock()
	defer fake.volumeCreateMutex.RUnlock()
	return len(fake.volumeCreateArgsForCall)
}

func (fake *fakeDockerClient) VolumeCreateArgsForCall(i int) (contextPkg.Context, volumetypes.VolumesCreateBody) {
	fake.volumeCreateMutex.RLock()
	defer fake.volumeCreateMutex.RUnlock()
	return fake.volumeCreateArgsForCall[i].ctx, fake.volumeCreateArgsForCall[i].options
}

func (fake *fakeDockerClient) VolumeCreateReturns(result1 types.Volume, result2 error) {
	fake.VolumeCreateStub = nil
	fake.volumeCreateReturns = struct {
		result1 types.Volume
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeCreateReturnsOnCall(i int, result1 types.Volume, result2 error) {
	fake.VolumeCreateStub = nil
	if fake.volumeCreateReturnsOnCall == nil {
		fake.volumeCreateReturnsOnCall = make(map[int]struct {
			result1 types.Volume
			result2 error
		})
	}
	fake.volumeCreateReturnsOnCall[i] = struct {
		result1 types.Volume
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeInspect(ctx contextPkg.Context, volumeID string) (types.Volume, error) {
	fake.volumeInspectMutex.Lock()
	ret, specificReturn := fake.volumeInspectReturnsOnCall[len(fake.volumeInspectArgsForCall)]
	fake.volumeInspectArgsForCall = append(fake.volumeInspectArgsForCall, struct {
		ctx      contextPkg.Context
		volumeID string
	}{ctx, volumeID})
	fake.recordInvocation("VolumeInspect", []interface{}{ctx, volumeID})
	fake.volumeInspectMutex.Unlock()
	if fake.VolumeInspectStub != nil {
		return fake.VolumeInspectStub(ctx, volumeID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.volumeInspectReturns.result1, fake.volumeInspectReturns.result2
}

func (fake *fakeDockerClient) VolumeInspectCallCount() int {
	fake.volumeInspectMutex.RLock()
	defer fake.volumeInspectMutex.RUnlock()
	return len(fake.volumeInspectArgsForCall)
}

func (fake *fakeDockerClient) VolumeInspectArgsForCall(i int) (contextPkg.Context, string) {
	fake.volumeInspectMutex.RLock()
	defer fake.volumeInspectMutex.RUnlock()
	return fake.volumeInspectArgsForCall[i].ctx, fake.volumeInspectArgsForCall[i].volumeID
}

func (fake *fakeDockerClient) VolumeInspectReturns(result1 types.Volume, result2 error) {
	fake.VolumeInspectStub = nil
	fake.volumeInspectReturns = struct {
		result1 types.Volume
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeInspectReturnsOnCall(i int, result1 types.Volume, result2 error) {
	fake.VolumeInspectStub = nil
	if fake.volumeInspectReturnsOnCall == nil {
		fake.volumeInspectReturnsOnCall = make(map[int]struct {
			result1 types.Volume
			result2 error
		})
	}
	fake.volumeInspectReturnsOnCall[i] = struct {
		result1 types.Volume
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeInspectWithRaw(ctx contextPkg.Context, volumeID string) (types.Volume, []byte, error) {
	fake.volumeInspectWithRawMutex.Lock()
	ret, specificReturn := fake.volumeInspectWithRawReturnsOnCall[len(fake.volumeInspectWithRawArgsForCall)]
	fake.volumeInspectWithRawArgsForCall = append(fake.volumeInspectWithRawArgsForCall, struct {
		ctx      contextPkg.Context
		volumeID string
	}{ctx, volumeID})
	fake.recordInvocation("VolumeInspectWithRaw", []interface{}{ctx, volumeID})
	fake.volumeInspectWithRawMutex.Unlock()
	if fake.VolumeInspectWithRawStub != nil {
		return fake.VolumeInspectWithRawStub(ctx, volumeID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.volumeInspectWithRawReturns.result1, fake.volumeInspectWithRawReturns.result2, fake.volumeInspectWithRawReturns.result3
}

func (fake *fakeDockerClient) VolumeInspectWithRawCallCount() int {
	fake.volumeInspectWithRawMutex.RLock()
	defer fake.volumeInspectWithRawMutex.RUnlock()
	return len(fake.volumeInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) VolumeInspectWithRawArgsForCall(i int) (contextPkg.Context, string) {
	fake.volumeInspectWithRawMutex.RLock()
	defer fake.volumeInspectWithRawMutex.RUnlock()
	return fake.volumeInspectWithRawArgsForCall[i].ctx, fake.volumeInspectWithRawArgsForCall[i].volumeID
}

func (fake *fakeDockerClient) VolumeInspectWithRawReturns(result1 types.Volume, result2 []byte, result3 error) {
	fake.VolumeInspectWithRawStub = nil
	fake.volumeInspectWithRawReturns = struct {
		result1 types.Volume
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) VolumeInspectWithRawReturnsOnCall(i int, result1 types.Volume, result2 []byte, result3 error) {
	fake.VolumeInspectWithRawStub = nil
	if fake.volumeInspectWithRawReturnsOnCall == nil {
		fake.volumeInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 types.Volume
			result2 []byte
			result3 error
		})
	}
	fake.volumeInspectWithRawReturnsOnCall[i] = struct {
		result1 types.Volume
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) VolumeList(ctx contextPkg.Context, filter filters.Args) (volumetypes.VolumesListOKBody, error) {
	fake.volumeListMutex.Lock()
	ret, specificReturn := fake.volumeListReturnsOnCall[len(fake.volumeListArgsForCall)]
	fake.volumeListArgsForCall = append(fake.volumeListArgsForCall, struct {
		ctx    contextPkg.Context
		filter filters.Args
	}{ctx, filter})
	fake.recordInvocation("VolumeList", []interface{}{ctx, filter})
	fake.volumeListMutex.Unlock()
	if fake.VolumeListStub != nil {
		return fake.VolumeListStub(ctx, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.volumeListReturns.result1, fake.volumeListReturns.result2
}

func (fake *fakeDockerClient) VolumeListCallCount() int {
	fake.volumeListMutex.RLock()
	defer fake.volumeListMutex.RUnlock()
	return len(fake.volumeListArgsForCall)
}

func (fake *fakeDockerClient) VolumeListArgsForCall(i int) (contextPkg.Context, filters.Args) {
	fake.volumeListMutex.RLock()
	defer fake.volumeListMutex.RUnlock()
	return fake.volumeListArgsForCall[i].ctx, fake.volumeListArgsForCall[i].filter
}

func (fake *fakeDockerClient) VolumeListReturns(result1 volumetypes.VolumesListOKBody, result2 error) {
	fake.VolumeListStub = nil
	fake.volumeListReturns = struct {
		result1 volumetypes.VolumesListOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeListReturnsOnCall(i int, result1 volumetypes.VolumesListOKBody, result2 error) {
	fake.VolumeListStub = nil
	if fake.volumeListReturnsOnCall == nil {
		fake.volumeListReturnsOnCall = make(map[int]struct {
			result1 volumetypes.VolumesListOKBody
			result2 error
		})
	}
	fake.volumeListReturnsOnCall[i] = struct {
		result1 volumetypes.VolumesListOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeRemove(ctx contextPkg.Context, volumeID string, force bool) error {
	fake.volumeRemoveMutex.Lock()
	ret, specificReturn := fake.volumeRemoveReturnsOnCall[len(fake.volumeRemoveArgsForCall)]
	fake.volumeRemoveArgsForCall = append(fake.volumeRemoveArgsForCall, struct {
		ctx      contextPkg.Context
		volumeID string
		force    bool
	}{ctx, volumeID, force})
	fake.recordInvocation("VolumeRemove", []interface{}{ctx, volumeID, force})
	fake.volumeRemoveMutex.Unlock()
	if fake.VolumeRemoveStub != nil {
		return fake.VolumeRemoveStub(ctx, volumeID, force)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.volumeRemoveReturns.result1
}

func (fake *fakeDockerClient) VolumeRemoveCallCount() int {
	fake.volumeRemoveMutex.RLock()
	defer fake.volumeRemoveMutex.RUnlock()
	return len(fake.volumeRemoveArgsForCall)
}

func (fake *fakeDockerClient) VolumeRemoveArgsForCall(i int) (contextPkg.Context, string, bool) {
	fake.volumeRemoveMutex.RLock()
	defer fake.volumeRemoveMutex.RUnlock()
	return fake.volumeRemoveArgsForCall[i].ctx, fake.volumeRemoveArgsForCall[i].volumeID, fake.volumeRemoveArgsForCall[i].force
}

func (fake *fakeDockerClient) VolumeRemoveReturns(result1 error) {
	fake.VolumeRemoveStub = nil
	fake.volumeRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) VolumeRemoveReturnsOnCall(i int, result1 error) {
	fake.VolumeRemoveStub = nil
	if fake.volumeRemoveReturnsOnCall == nil {
		fake.volumeRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.volumeRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) VolumesPrune(ctx contextPkg.Context, pruneFilter filters.Args) (types.VolumesPruneReport, error) {
	fake.volumesPruneMutex.Lock()
	ret, specificReturn := fake.volumesPruneReturnsOnCall[len(fake.volumesPruneArgsForCall)]
	fake.volumesPruneArgsForCall = append(fake.volumesPruneArgsForCall, struct {
		ctx         contextPkg.Context
		pruneFilter filters.Args
	}{ctx, pruneFilter})
	fake.recordInvocation("VolumesPrune", []interface{}{ctx, pruneFilter})
	fake.volumesPruneMutex.Unlock()
	if fake.VolumesPruneStub != nil {
		return fake.VolumesPruneStub(ctx, pruneFilter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.volumesPruneReturns.result1, fake.volumesPruneReturns.result2
}

func (fake *fakeDockerClient) VolumesPruneCallCount() int {
	fake.volumesPruneMutex.RLock()
	defer fake.volumesPruneMutex.RUnlock()
	return len(fake.volumesPruneArgsForCall)
}

func (fake *fakeDockerClient) VolumesPruneArgsForCall(i int) (contextPkg.Context, filters.Args) {
	fake.volumesPruneMutex.RLock()
	defer fake.volumesPruneMutex.RUnlock()
	return fake.volumesPruneArgsForCall[i].ctx, fake.volumesPruneArgsForCall[i].pruneFilter
}

func (fake *fakeDockerClient) VolumesPruneReturns(result1 types.VolumesPruneReport, result2 error) {
	fake.VolumesPruneStub = nil
	fake.volumesPruneReturns = struct {
		result1 types.VolumesPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumesPruneReturnsOnCall(i int, result1 types.VolumesPruneReport, result2 error) {
	fake.VolumesPruneStub = nil
	if fake.volumesPruneReturnsOnCall == nil {
		fake.volumesPruneReturnsOnCall = make(map[int]struct {
			result1 types.VolumesPruneReport
			result2 error
		})
	}
	fake.volumesPruneReturnsOnCall[i] = struct {
		result1 types.VolumesPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ClientVersion() string {
	fake.clientVersionMutex.Lock()
	ret, specificReturn := fake.clientVersionReturnsOnCall[len(fake.clientVersionArgsForCall)]
	fake.clientVersionArgsForCall = append(fake.clientVersionArgsForCall, struct{}{})
	fake.recordInvocation("ClientVersion", []interface{}{})
	fake.clientVersionMutex.Unlock()
	if fake.ClientVersionStub != nil {
		return fake.ClientVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.clientVersionReturns.result1
}

func (fake *fakeDockerClient) ClientVersionCallCount() int {
	fake.clientVersionMutex.RLock()
	defer fake.clientVersionMutex.RUnlock()
	return len(fake.clientVersionArgsForCall)
}

func (fake *fakeDockerClient) ClientVersionReturns(result1 string) {
	fake.ClientVersionStub = nil
	fake.clientVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *fakeDockerClient) ClientVersionReturnsOnCall(i int, result1 string) {
	fake.ClientVersionStub = nil
	if fake.clientVersionReturnsOnCall == nil {
		fake.clientVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.clientVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *fakeDockerClient) DaemonHost() string {
	fake.daemonHostMutex.Lock()
	ret, specificReturn := fake.daemonHostReturnsOnCall[len(fake.daemonHostArgsForCall)]
	fake.daemonHostArgsForCall = append(fake.daemonHostArgsForCall, struct{}{})
	fake.recordInvocation("DaemonHost", []interface{}{})
	fake.daemonHostMutex.Unlock()
	if fake.DaemonHostStub != nil {
		return fake.DaemonHostStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.daemonHostReturns.result1
}

func (fake *fakeDockerClient) DaemonHostCallCount() int {
	fake.daemonHostMutex.RLock()
	defer fake.daemonHostMutex.RUnlock()
	return len(fake.daemonHostArgsForCall)
}

func (fake *fakeDockerClient) DaemonHostReturns(result1 string) {
	fake.DaemonHostStub = nil
	fake.daemonHostReturns = struct {
		result1 string
	}{result1}
}

func (fake *fakeDockerClient) DaemonHostReturnsOnCall(i int, result1 string) {
	fake.DaemonHostStub = nil
	if fake.daemonHostReturnsOnCall == nil {
		fake.daemonHostReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.daemonHostReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *fakeDockerClient) ServerVersion(ctx contextPkg.Context) (types.Version, error) {
	fake.serverVersionMutex.Lock()
	ret, specificReturn := fake.serverVersionReturnsOnCall[len(fake.serverVersionArgsForCall)]
	fake.serverVersionArgsForCall = append(fake.serverVersionArgsForCall, struct {
		ctx contextPkg.Context
	}{ctx})
	fake.recordInvocation("ServerVersion", []interface{}{ctx})
	fake.serverVersionMutex.Unlock()
	if fake.ServerVersionStub != nil {
		return fake.ServerVersionStub(ctx)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.serverVersionReturns.result1, fake.serverVersionReturns.result2
}

func (fake *fakeDockerClient) ServerVersionCallCount() int {
	fake.serverVersionMutex.RLock()
	defer fake.serverVersionMutex.RUnlock()
	return len(fake.serverVersionArgsForCall)
}

func (fake *fakeDockerClient) ServerVersionArgsForCall(i int) contextPkg.Context {
	fake.serverVersionMutex.RLock()
	defer fake.serverVersionMutex.RUnlock()
	return fake.serverVersionArgsForCall[i].ctx
}

func (fake *fakeDockerClient) ServerVersionReturns(result1 types.Version, result2 error) {
	fake.ServerVersionStub = nil
	fake.serverVersionReturns = struct {
		result1 types.Version
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServerVersionReturnsOnCall(i int, result1 types.Version, result2 error) {
	fake.ServerVersionStub = nil
	if fake.serverVersionReturnsOnCall == nil {
		fake.serverVersionReturnsOnCall = make(map[int]struct {
			result1 types.Version
			result2 error
		})
	}
	fake.serverVersionReturnsOnCall[i] = struct {
		result1 types.Version
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NegotiateAPIVersion(ctx contextPkg.Context) {
	fake.negotiateAPIVersionMutex.Lock()
	fake.negotiateAPIVersionArgsForCall = append(fake.negotiateAPIVersionArgsForCall, struct {
		ctx contextPkg.Context
	}{ctx})
	fake.recordInvocation("NegotiateAPIVersion", []interface{}{ctx})
	fake.negotiateAPIVersionMutex.Unlock()
	if fake.NegotiateAPIVersionStub != nil {
		fake.NegotiateAPIVersionStub(ctx)
	}
}

func (fake *fakeDockerClient) NegotiateAPIVersionCallCount() int {
	fake.negotiateAPIVersionMutex.RLock()
	defer fake.negotiateAPIVersionMutex.RUnlock()
	return len(fake.negotiateAPIVersionArgsForCall)
}

func (fake *fakeDockerClient) NegotiateAPIVersionArgsForCall(i int) contextPkg.Context {
	fake.negotiateAPIVersionMutex.RLock()
	defer fake.negotiateAPIVersionMutex.RUnlock()
	return fake.negotiateAPIVersionArgsForCall[i].ctx
}

func (fake *fakeDockerClient) NegotiateAPIVersionPing(arg1 types.Ping) {
	fake.negotiateAPIVersionPingMutex.Lock()
	fake.negotiateAPIVersionPingArgsForCall = append(fake.negotiateAPIVersionPingArgsForCall, struct {
		arg1 types.Ping
	}{arg1})
	fake.recordInvocation("NegotiateAPIVersionPing", []interface{}{arg1})
	fake.negotiateAPIVersionPingMutex.Unlock()
	if fake.NegotiateAPIVersionPingStub != nil {
		fake.NegotiateAPIVersionPingStub(arg1)
	}
}

func (fake *fakeDockerClient) NegotiateAPIVersionPingCallCount() int {
	fake.negotiateAPIVersionPingMutex.RLock()
	defer fake.negotiateAPIVersionPingMutex.RUnlock()
	return len(fake.negotiateAPIVersionPingArgsForCall)
}

func (fake *fakeDockerClient) NegotiateAPIVersionPingArgsForCall(i int) types.Ping {
	fake.negotiateAPIVersionPingMutex.RLock()
	defer fake.negotiateAPIVersionPingMutex.RUnlock()
	return fake.negotiateAPIVersionPingArgsForCall[i].arg1
}

func (fake *fakeDockerClient) DialSession(ctx contextPkg.Context, proto string, meta map[string][]string) (net.Conn, error) {
	fake.dialSessionMutex.Lock()
	ret, specificReturn := fake.dialSessionReturnsOnCall[len(fake.dialSessionArgsForCall)]
	fake.dialSessionArgsForCall = append(fake.dialSessionArgsForCall, struct {
		ctx   contextPkg.Context
		proto string
		meta  map[string][]string
	}{ctx, proto, meta})
	fake.recordInvocation("DialSession", []interface{}{ctx, proto, meta})
	fake.dialSessionMutex.Unlock()
	if fake.DialSessionStub != nil {
		return fake.DialSessionStub(ctx, proto, meta)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.dialSessionReturns.result1, fake.dialSessionReturns.result2
}

func (fake *fakeDockerClient) DialSessionCallCount() int {
	fake.dialSessionMutex.RLock()
	defer fake.dialSessionMutex.RUnlock()
	return len(fake.dialSessionArgsForCall)
}

func (fake *fakeDockerClient) DialSessionArgsForCall(i int) (contextPkg.Context, string, map[string][]string) {
	fake.dialSessionMutex.RLock()
	defer fake.dialSessionMutex.RUnlock()
	return fake.dialSessionArgsForCall[i].ctx, fake.dialSessionArgsForCall[i].proto, fake.dialSessionArgsForCall[i].meta
}

func (fake *fakeDockerClient) DialSessionReturns(result1 net.Conn, result2 error) {
	fake.DialSessionStub = nil
	fake.dialSessionReturns = struct {
		result1 net.Conn
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) DialSessionReturnsOnCall(i int, result1 net.Conn, result2 error) {
	fake.DialSessionStub = nil
	if fake.dialSessionReturnsOnCall == nil {
		fake.dialSessionReturnsOnCall = make(map[int]struct {
			result1 net.Conn
			result2 error
		})
	}
	fake.dialSessionReturnsOnCall[i] = struct {
		result1 net.Conn
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct{}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.closeReturns.result1
}

func (fake *fakeDockerClient) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *fakeDockerClient) CloseReturns(result1 error) {
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) CloseReturnsOnCall(i int, result1 error) {
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.configListMutex.RLock()
	defer fake.configListMutex.RUnlock()
	fake.configCreateMutex.RLock()
	defer fake.configCreateMutex.RUnlock()
	fake.configRemoveMutex.RLock()
	defer fake.configRemoveMutex.RUnlock()
	fake.configInspectWithRawMutex.RLock()
	defer fake.configInspectWithRawMutex.RUnlock()
	fake.configUpdateMutex.RLock()
	defer fake.configUpdateMutex.RUnlock()
	fake.containerAttachMutex.RLock()
	defer fake.containerAttachMutex.RUnlock()
	fake.containerCommitMutex.RLock()
	defer fake.containerCommitMutex.RUnlock()
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	fake.containerDiffMutex.RLock()
	defer fake.containerDiffMutex.RUnlock()
	fake.containerExecAttachMutex.RLock()
	defer fake.containerExecAttachMutex.RUnlock()
	fake.containerExecCreateMutex.RLock()
	defer fake.containerExecCreateMutex.RUnlock()
	fake.containerExecInspectMutex.RLock()
	defer fake.containerExecInspectMutex.RUnlock()
	fake.containerExecResizeMutex.RLock()
	defer fake.containerExecResizeMutex.RUnlock()
	fake.containerExecStartMutex.RLock()
	defer fake.containerExecStartMutex.RUnlock()
	fake.containerExportMutex.RLock()
	defer fake.containerExportMutex.RUnlock()
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	fake.containerInspectWithRawMutex.RLock()
	defer fake.containerInspectWithRawMutex.RUnlock()
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	fake.containerListMutex.RLock()
	defer fake.containerListMutex.RUnlock()
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	fake.containerPauseMutex.RLock()
	defer fake.containerPauseMutex.RUnlock()
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	fake.containerRenameMutex.RLock()
	defer fake.containerRenameMutex.RUnlock()
	fake.containerResizeMutex.RLock()
	defer fake.containerResizeMutex.RUnlock()
	fake.containerRestartMutex.RLock()
	defer fake.containerRestartMutex.RUnlock()
	fake.containerStatPathMutex.RLock()
	defer fake.containerStatPathMutex.RUnlock()
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	fake.containerTopMutex.RLock()
	defer fake.containerTopMutex.RUnlock()
	fake.containerUnpauseMutex.RLock()
	defer fake.containerUnpauseMutex.RUnlock()
	fake.containerUpdateMutex.RLock()
	defer fake.containerUpdateMutex.RUnlock()
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	fake.copyFromContainerMutex.RLock()
	defer fake.copyFromContainerMutex.RUnlock()
	fake.copyToContainerMutex.RLock()
	defer fake.copyToContainerMutex.RUnlock()
	fake.containersPruneMutex.RLock()
	defer fake.containersPruneMutex.RUnlock()
	fake.distributionInspectMutex.RLock()
	defer fake.distributionInspectMutex.RUnlock()
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	fake.buildCachePruneMutex.RLock()
	defer fake.buildCachePruneMutex.RUnlock()
	fake.imageCreateMutex.RLock()
	defer fake.imageCreateMutex.RUnlock()
	fake.imageHistoryMutex.RLock()
	defer fake.imageHistoryMutex.RUnlock()
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	fake.imageInspectWithRawMutex.RLock()
	defer fake.imageInspectWithRawMutex.RUnlock()
	fake.imageListMutex.RLock()
	defer fake.imageListMutex.RUnlock()
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	fake.imagePushMutex.RLock()
	defer fake.imagePushMutex.RUnlock()
	fake.imageRemoveMutex.RLock()
	defer fake.imageRemoveMutex.RUnlock()
	fake.imageSearchMutex.RLock()
	defer fake.imageSearchMutex.RUnlock()
	fake.imageSaveMutex.RLock()
	defer fake.imageSaveMutex.RUnlock()
	fake.imageTagMutex.RLock()
	defer fake.imageTagMutex.RUnlock()
	fake.imagesPruneMutex.RLock()
	defer fake.imagesPruneMutex.RUnlock()
	fake.nodeInspectWithRawMutex.RLock()
	defer fake.nodeInspectWithRawMutex.RUnlock()
	fake.nodeListMutex.RLock()
	defer fake.nodeListMutex.RUnlock()
	fake.nodeRemoveMutex.RLock()
	defer fake.nodeRemoveMutex.RUnlock()
	fake.nodeUpdateMutex.RLock()
	defer fake.nodeUpdateMutex.RUnlock()
	fake.networkConnectMutex.RLock()
	defer fake.networkConnectMutex.RUnlock()
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	fake.networkDisconnectMutex.RLock()
	defer fake.networkDisconnectMutex.RUnlock()
	fake.networkInspectMutex.RLock()
	defer fake.networkInspectMutex.RUnlock()
	fake.networkInspectWithRawMutex.RLock()
	defer fake.networkInspectWithRawMutex.RUnlock()
	fake.networkListMutex.RLock()
	defer fake.networkListMutex.RUnlock()
	fake.networkRemoveMutex.RLock()
	defer fake.networkRemoveMutex.RUnlock()
	fake.networksPruneMutex.RLock()
	defer fake.networksPruneMutex.RUnlock()
	fake.pluginListMutex.RLock()
	defer fake.pluginListMutex.RUnlock()
	fake.pluginRemoveMutex.RLock()
	defer fake.pluginRemoveMutex.RUnlock()
	fake.pluginEnableMutex.RLock()
	defer fake.pluginEnableMutex.RUnlock()
	fake.pluginDisableMutex.RLock()
	defer fake.pluginDisableMutex.RUnlock()
	fake.pluginInstallMutex.RLock()
	defer fake.pluginInstallMutex.RUnlock()
	fake.pluginUpgradeMutex.RLock()
	defer fake.pluginUpgradeMutex.RUnlock()
	fake.pluginPushMutex.RLock()
	defer fake.pluginPushMutex.RUnlock()
	fake.pluginSetMutex.RLock()
	defer fake.pluginSetMutex.RUnlock()
	fake.pluginInspectWithRawMutex.RLock()
	defer fake.pluginInspectWithRawMutex.RUnlock()
	fake.pluginCreateMutex.RLock()
	defer fake.pluginCreateMutex.RUnlock()
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	fake.serviceInspectWithRawMutex.RLock()
	defer fake.serviceInspectWithRawMutex.RUnlock()
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	fake.serviceRemoveMutex.RLock()
	defer fake.serviceRemoveMutex.RUnlock()
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	fake.serviceLogsMutex.RLock()
	defer fake.serviceLogsMutex.RUnlock()
	fake.taskLogsMutex.RLock()
	defer fake.taskLogsMutex.RUnlock()
	fake.taskInspectWithRawMutex.RLock()
	defer fake.taskInspectWithRawMutex.RUnlock()
	fake.taskListMutex.RLock()
	defer fake.taskListMutex.RUnlock()
	fake.swarmInitMutex.RLock()
	defer fake.swarmInitMutex.RUnlock()
	fake.swarmJoinMutex.RLock()
	defer fake.swarmJoinMutex.RUnlock()
	fake.swarmGetUnlockKeyMutex.RLock()
	defer fake.swarmGetUnlockKeyMutex.RUnlock()
	fake.swarmUnlockMutex.RLock()
	defer fake.swarmUnlockMutex.RUnlock()
	fake.swarmLeaveMutex.RLock()
	defer fake.swarmLeaveMutex.RUnlock()
	fake.swarmInspectMutex.RLock()
	defer fake.swarmInspectMutex.RUnlock()
	fake.swarmUpdateMutex.RLock()
	defer fake.swarmUpdateMutex.RUnlock()
	fake.secretListMutex.RLock()
	defer fake.secretListMutex.RUnlock()
	fake.secretCreateMutex.RLock()
	defer fake.secretCreateMutex.RUnlock()
	fake.secretRemoveMutex.RLock()
	defer fake.secretRemoveMutex.RUnlock()
	fake.secretInspectWithRawMutex.RLock()
	defer fake.secretInspectWithRawMutex.RUnlock()
	fake.secretUpdateMutex.RLock()
	defer fake.secretUpdateMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.registryLoginMutex.RLock()
	defer fake.registryLoginMutex.RUnlock()
	fake.diskUsageMutex.RLock()
	defer fake.diskUsageMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.volumeCreateMutex.RLock()
	defer fake.volumeCreateMutex.RUnlock()
	fake.volumeInspectMutex.RLock()
	defer fake.volumeInspectMutex.RUnlock()
	fake.volumeInspectWithRawMutex.RLock()
	defer fake.volumeInspectWithRawMutex.RUnlock()
	fake.volumeListMutex.RLock()
	defer fake.volumeListMutex.RUnlock()
	fake.volumeRemoveMutex.RLock()
	defer fake.volumeRemoveMutex.RUnlock()
	fake.volumesPruneMutex.RLock()
	defer fake.volumesPruneMutex.RUnlock()
	fake.clientVersionMutex.RLock()
	defer fake.clientVersionMutex.RUnlock()
	fake.daemonHostMutex.RLock()
	defer fake.daemonHostMutex.RUnlock()
	fake.serverVersionMutex.RLock()
	defer fake.serverVersionMutex.RUnlock()
	fake.negotiateAPIVersionMutex.RLock()
	defer fake.negotiateAPIVersionMutex.RUnlock()
	fake.negotiateAPIVersionPingMutex.RLock()
	defer fake.negotiateAPIVersionPingMutex.RUnlock()
	fake.dialSessionMutex.RLock()
	defer fake.dialSessionMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *fakeDockerClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.CommonAPIClient = new(fakeDockerClient)
